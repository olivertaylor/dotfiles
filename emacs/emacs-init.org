#+TITLE: Emacs Settings & Configuration
#+AUTHOR: Oliver Taylor

* Hello!

/Welcome!/ I'm sorry, but I'm not writing this for you, I'm writing this for me---well, /future/-me. I don't want to forget how this configuration file works, or why I did things this way, so I write it in [[https://en.wikipedia.org/wiki/Literate_programming][this format]] so I can read it later and understand what the hell /past/-me was thinking.

** What is This?

This document does 2 things simultaneously, it is both the configuration file containing all my settings and preferences that Emacs reads when it starts-up /and/ it is a document that's meant to be read by a human which explains what the configuration and settings do and why I want them done that way.

This file is called =emacs-init.org= and to make it work, you need the following in your =~/.emacs.d/init.el=:

#+begin_example
(require 'org)
(org-babel-load-file (expand-file-name "~/dot/emacs/emacs-init.org"))
#+end_example

** My Emacs Philosophy

1. Using Emacs makes no sense unless you customize it extensively. If you're not interested in, or don't want to bother with, customizing Emacs to the point where it molds around what you expect of it (rather than requiring /you to mold to it/) then save yourself the trouble and use another editor, there are a lot of great ones.

2. Accept that you will never remember Emacs keybindings, and that even if you do it will injure your pinky, and don't even bother trying. That's not a down-side, it means you don't have to learn anything new (!), just learn to make Emacs work the way you expect it to. That sounds like it might be difficult, but once you get the hang of customizing Emacs it becomes easy.

3. There's a few things you should learn to use in order to learn about Emacs's capabilities. Poke around =C-h ?= for Help. Use =counsel-M-x= to explore. Use =which-key= to give you hints for difficult to remember shortcuts.

4. Use =hydra= to set up what are basically "mini-modes". I don't know how I'd function without the one I have setup for window management. And the vim-ish hydra below is very useful indeed. As the saying goes "the best editor is not vim or emacs, but both".

** Inspiration and References

Anyone learning vim, emacs, zsh, bash, or something similar, spends a lot of time looking at other people's configuration files (much like this one). I've learned from some wonderful (and well documented) examples. Here is a list of the ones I've learned the most from:

- [[https://protesilaos.com/dotemacs/][Protesilaos Stavrou Dotemacs]]
- [[https://blog.aaronbieber.com][Aaron Bieber, Blog & Dotfiles]]
- [[https://github.com/hrs/dotfiles/blob/main/emacs/dot-emacs.d/configuration.org][Harry R. Schwartz dotfiles]]
- [[https://yiufung.net/post/org-mode-hidden-gems-pt1/][Org-Mode Hidden Gems]]

For more sources see [[https://pinboard.in/u:Oliver/t:emacs][my pinboard bookmarks]].

* Settings

** Setup

Set encoding to be UTF-8 everywhere.

#+begin_src emacs-lisp
(setq-default buffer-file-coding-system 'utf-8-unix)
(set-default-coding-systems 'utf-8-unix)
(setq locale-coding-system 'utf-8-unix)
(prefer-coding-system 'utf-8-unix)
#+end_src

When customizing Emacs interactively (ie: not in this document or =init.el=) Emacs appends code to your =init.el= file, which can be annoying when editing it by hand. This tells Emacs to place these customizations in a separate file.

#+begin_src emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(when (file-exists-p custom-file)
  (load custom-file :noerror))
#+end_src

This tells emacs how I've laid-out by emacs directory.

#+begin_src emacs-lisp
(add-to-list 'custom-theme-load-path (expand-file-name "themes" user-emacs-directory))
(setq backup-directory-alist `(("." . "~/.emacs.d/saves")))
#+end_src

The below is probably the biggest reason why I managed get over the intimidation of using Emacs in those first few days. Here's what it does:

1. Makes the command keys act as =super=. =super= keybindings are basically not used by Emacs so they're a safe playground for assigning your own keybindings. I setup =s-q= for quit,  =s-s= for save, =s-z= for undo, =s-o= for open file, basically, all the standard Mac shortcuts. Once I did that Emacs became very usable immediately and that ease-of-use made learning Emacs a lot less painful.
2. Makes the right option key act as =meta= and the makes the left option key act as =alt=. This lets me use =meta= keybindings /and/ type characters that require =option/alt=. If you don't do that you can't insert characters like: £¢∞§¶•≠. Which is, I guess, only sometimes useful, but at least this way I /can/.

#+begin_src emacs-lisp
;; Command to super
(setq mac-command-modifier 'super)
(setq mac-right-command-modifier 'super)
;; Left-option to meta
(setq mac-option-modifier 'meta)
(setq mac-left-option-modifier 'meta)
;; Right-option to option
(setq mac-right-option-modifier 'meta)
(setq mac-right-option-modifier 'nil)
#+end_src

Due to historical reasons, emacs thinks =C-i= is the same as =TAB= and =C-m= is the same as =RETURN=. The below undoes that assumption.

#+begin_src emacs-lisp
(define-key input-decode-map [?\C-i] [C-i])
(global-set-key (kbd "<C-i>") nil)
(define-key input-decode-map [?\C-m] [C-m])
(global-set-key (kbd "<C-m>") nil)
#+end_src

When editing 2 files with the same name, like =~/foo/file= and =~/bar/file=, Emacs (amazingly) refers to those files as =file<~/foo>= and =file<~/bar>=. This makes Emacs refer to them as =foo/file= and =bar/file=, like a sane program.

#+begin_src emacs-lisp
;;(require 'uniquify)
(setq uniquify-buffer-name-style 'forward)
#+end_src

This tells emacs to startup with a scratch buffer, with custom content, and to do it quietly.

#+begin_src emacs-lisp
(setq initial-scratch-message
      (concat
       ";; This buffer is for text that is not saved, and for Lisp evaluation.\n"
       ";; To create a file, visit it with C-x C-f and enter text in its buffer.\n"
       ";; WELCOME TO EMACS\n"))
(setq inhibit-splash-screen t
      inhibit-startup-message t
      inhibit-startup-echo-area-message t)
#+end_src

** General

#+begin_src emacs-lisp
;; The menu-bar-mode must be set to 1 to integrate well with macOS
(menu-bar-mode 1) 
(tool-bar-mode -1)
(show-paren-mode t) ;highlight parens
(setq show-paren-delay 0)
(delete-selection-mode t)
(global-auto-revert-mode t)
(desktop-save-mode 1) ;sessions
(save-place-mode 1) ;reopens the file to the same spot you left
(recentf-mode 1) ;enables "Open Recent..." in file menu
(setq visible-bell t)
(setq tab-width 4)

;; I type one space after sentences, because I'm not a monster.
(setq sentence-end-double-space nil)

(setq ispell-program-name "/usr/local/bin/aspell")
(customize-set-variable 'ispell-extra-args '("--sug-mode=ultra"))
(setq ispell-list-command "list")
#+end_src

** Visual Line Mode

Visual line mode is super helpful, but out-of-the-box it behaves inconsistently with the rest of macOS, so this includes code to make it the same.

#+begin_src emacs-lisp
;; WORD WRAP
(global-visual-line-mode t)
;; with visual-line-mode set,
;; C-a and C-b go to beginning/end-of-visual-line
;; which is inconsistant with standard Mac behaviour
;; so I've bound those to command-left/right
(global-set-key (kbd "C-a") 'beginning-of-line)
(global-set-key (kbd "C-e") 'end-of-line)
(global-set-key (kbd "s-<left>") 'beginning-of-visual-line)
(global-set-key (kbd "s-<right>") 'end-of-visual-line)
#+end_src

** Enable Packages, and Their Basic Settings

#+begin_src emacs-lisp
(which-key-mode t)              ;hints
(global-undo-tree-mode t)       ;activate undo-tree everywhere
(require 'expand-region)        ;lovely plugin

(add-to-list 'load-path (expand-file-name "lisp/emacs-sdcv" user-emacs-directory))
(require 'sdcv-mode)            ;dictionary lookup, requires sdcv on $PATH

;; counsel settings
(counsel-mode t)
(setq ivy-use-virtual-buffers t)
(setq enable-recursive-minibuffers t)
(setq ivy-count-format "(%d/%d) ")
;; by default ivy starts up with ^ in the input area this means you
;; have to know the first letter of what you're looking for. You can
;; set this to nil to change that.
;; (setq ivy-initial-inputs-alist nil)

;; Hide details in dired mode
(add-hook 'dired-mode-hook
          (lambda ()
            (dired-hide-details-mode 1)))

(require 'bind-key)
#+end_src

You can ensure packages are installed with something like this (no need for use-package!):

#+begin_example
(unless (package-installed-p 'super-save)
  (package-refresh-contents)
  (package-install 'super-save))
#+end_example

* Appearance

Here the fonts are setup in a function so I can change them all in once step by calling =oht/set-font=.

#+begin_src emacs-lisp
(defun oht/set-font ()
(set-face-attribute 'default nil
		     :family "SF Mono" :height 130 :weight 'normal)
(set-face-attribute 'fixed-pitch nil
                     :family "Iosevka Fixed SS08" :height 140 :weight 'normal)
(set-face-attribute 'variable-pitch nil
	             :family "IBM Plex Serif" :height 150 :weight 'normal))

(set-default 'cursor-type 'bar)
;; Underline line at descent position, not baseline position
(setq x-underline-at-descent-line t)

;; the bold settings here do not seem to effect variable-pitch settings
(setq modus-operandi-theme-slanted-constructs t
      modus-vivendi-theme-slanted-constructs t
      modus-operandi-theme-rainbow-headings nil
      modus-operandi-theme-distinct-org-blocks t
      modus-operandi-theme-org-blocks 'rainbow
      )

(load-theme 'modus-operandi t)
(oht/set-font)

(defadvice load-theme (before clear-previous-themes activate)
  "Clear existing theme settings instead of layering them"
  (mapc #'disable-theme custom-enabled-themes))

;; size of frame at startup
(setq initial-frame-alist '((height . 60)(width . 80)))
;; size of new frames
(setq default-frame-alist '((height . 60)(width . 80)))
#+end_src

** Minions

Hide all minor-modes behind a menu in the modeline.

#+begin_src emacs-lisp
(minions-mode t)
#+end_src

** ModeLine

This currently replicates the default mode-line. At some point in the future I may want to customize it.

#+begin_src emacs-lisp
(setq-default mode-line-format
              '("%e"
                mode-line-front-space
                mode-line-mule-info
                mode-line-client
                mode-line-modified
                mode-line-remote
                mode-line-frame-identification
                mode-line-buffer-identification
                "  "
                mode-line-position
                (vc-mode vc-mode)
                " "
                mode-line-modes
                " "
                mode-line-misc-info
                mode-line-end-spaces))
#+end_src

* Org

** General

#+begin_src emacs-lisp
;; fix the look of source code blocks
(setq org-src-fontify-natively t)
(setq org-src-tab-acts-natively t)
(setq org-edit-src-content-indentation 0)

;; do not indent text below a headline
(setq org-adapt-indentation nil)

(setq org-hide-leading-stars 't)

;; by default, hide org-markup
;; I have a toggle for this defined in functions
(setq org-hide-emphasis-markers t)

;; Style quote and verse blocks
(setq org-fontify-quote-and-verse-blocks t)

;; This adds [COMPLETED: DATE] when you move something to a "done" state
(setq org-log-done 'time)

;; Tags start immediately after the headline
(setq org-tags-column 0)

;; This prevents editing inside folded sections
(setq org-catch-invisible-edits 'show-and-error)

;; This sets the sequence of plain list bullets
;; The syntax is confusing and I don't understand it,
;; but I like the results.
(setq org-list-demote-modify-bullet '(("+" . "-") ("-" . "+") ("*" . "+")))

;; Increase sub-item indentation by this amount
;; the default is 2 so the below means 2+2 = 4 (spaces)
(setq org-list-indent-offset 2)

;; this tells org to use the current window for agenda
;; rather than creating a split
(setq org-agenda-window-setup 'current-window)

;; Ensure that a task can’t be marked as done if it contains
;; unfinished subtasks or checklist items. This is handy for
;; organizing “blocking” tasks hierarchically.
(setq org-enforce-todo-dependencies t)
(setq org-enforce-todo-checkbox-dependencies t)

(add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
(add-to-list 'org-structure-template-alist '("f" . "src fountain"))

;; this sets "refile targets" to any headline, level 1-3, in you agenda files.
(setq org-refile-targets
      '((org-agenda-files :maxlevel . 3)))
(setq org-refile-allow-creating-parent-nodes 'confirm)
#+end_src

** Org Agenda & TODOs

#+begin_src emacs-lisp
(setq org-todo-keywords
      '((sequence "TODO(t)" "|" "DONE(d)")
        (sequence "WAIT(w)" "|" "CANCELLED(c)")))

(setq org-agenda-files (quote (
                               "~/Documents/org-files/"
                               "~/Documents/writing/kindred/compendium.org"
                               )))

(setq org-agenda-custom-commands
      '(
        ("d" "Do Now - Not scheduled, #A, TODO"
         ((agenda "d" ((org-agenda-span 'day)))
          (tags "+PRIORITY={A}/TODO"
                ((org-agenda-overriding-header "Tasks you should do NOW:")
                 (org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled))
                 ))))
        ("i" "Important Tasks"
         ((tags "-consume-PRIORITY={C}/TODO"
                ((org-agenda-overriding-header "Important Tasks")
                (org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled)))
                )))
        ("c" "Complete - Agenda and ALL todos"
         ((agenda "")
          (todo "TODO|WAIT"
                ((org-agenda-overriding-header "Global list of TODO items of type: ALL (non-scheduled)")
                 (org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled))
                 ))
          ))
        ))

(setq org-capture-templates
      '(("p" "Personal Inbox" entry
         (file+headline "~/Documents/org-files/refile.org" "Personal")
         "* %?\n\n")
        ("P" "Personal Log Entry" entry
         (file "~/Documents/org-files/logbook.org")
         "* %?\n%t\n\n")
        ("i" "Ingenuity Inbox" entry
         (file+headline "~/Documents/org-files/refile.org" "Ingenuity")
         "* %?\n\n")
        ("I" "Ingenuity Log Entry" entry
         (file "~/Documents/org-files/ing_log.org")
         "* %^{Log type|Meeting: |Call: } %? %t\n\n")
        ))
#+end_src

** Tags

I find tags to be of very limited utility, but it is useful to tag truly unimportant things to that you can match filter them out of your agenda view. You can group those tags so that you only have to match against the group name.

#+begin_src emacs-lisp
(setq org-tag-alist '(
		      (:startgroup)
		      ("consume" . ?c)
		      (:grouptags)
		      ("read" . ?r) ("buy" . ?b)
		      (:endgroup)
		      ;; below, ungrouped
		      ("errand" . ?e)
		      ))
#+end_src

* Functions

#+begin_src emacs-lisp
(defun oht/writing-mode ()
  "Enable variable-pitch, flyspell, and increased line-spacing and margins."
  (interactive)
  (variable-pitch-mode t)
  (flyspell-mode t)
  (setq-local line-spacing 0.15)
  ;; define width of buffer margins
  (setq-local left-margin-width 1)
  (setq-local right-margin-width 1)
  ;;(set-window-buffer nil (current-buffer)) ; Use them now.
  )

(defun oht/fix-variable-org-indent ()
  "Fix for org-indent not hiding markup in org-indent-mode.
from: https://maxjmartin.com/Emacs%20Dotfile.html"
  (interactive)
  (set-face-attribute 'org-indent nil :inherit '(org-hide fixed-pitch))
  )

(defun oht/counsel-find-settings ()
  "Quickly open emacs-init.org"
  (interactive)
  (find-file "~/dot/emacs/emacs-init.org"))

(defun oht/counsel-find-org ()
  "Quickly open ~/Documents/org-files/"
  (interactive)
  (counsel-find-file "~/Documents/org-files/"))

(defun oht/kill-this-buffer ()
  "Quickly kill current buffer"
  (interactive)
  (kill-buffer (current-buffer)))

(defun oht/find-scratch ()
  (interactive)
  (if (string= (buffer-name) "*scratch*")
      (previous-buffer)
    (switch-to-buffer "*scratch*")))

;; Move Lines
(defmacro save-column (&rest body)
  `(let ((column (current-column)))
     (unwind-protect
         (progn ,@body)
       (move-to-column column))))
(put 'save-column 'lisp-indent-function 0)
(defun move-line-up ()
  "Move the current line up by 1 line"
  (interactive)
  (save-column
    (transpose-lines 1)
    (forward-line -2)))
(defun move-line-down ()
  "More the current line down by 1 line"
  (interactive)
  (save-column
    (forward-line 1)
    (transpose-lines 1)
    (forward-line -1)))

(defun oht/mark-whole-line ()
  "Mark the entirety of the current line."
  (interactive)
  (beginning-of-line)
  (set-mark-command nil)
  (end-of-line))

(defun oht/toggle-window-split ()
  "Toggle between vertical and horizontal split."
  ;; Source: https://www.emacswiki.org/emacs/ToggleWindowSplit.
  ;; Author: Jeff Dwork
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                         (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                         (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))

(defun oht/open-in-bbedit ()
  "Open current file or dir in BBEdit.
Adapted from:
URL `http://ergoemacs.org/emacs/emacs_dired_open_file_in_ext_apps.html'"
  (interactive)
  (let (($path (if (buffer-file-name) (buffer-file-name) (expand-file-name default-directory ) )))
    (message "path is %s" $path)
    (string-equal system-type "darwin")
    (shell-command (format "open -a BBEdit \"%s\"" $path))))

(defun oht/expand-to-beginning-of-visual-line ()
  "Set mark and move to beginning of visual line"
  (interactive)
  (set-mark-command nil)
  (beginning-of-visual-line)
  )
(defun oht/expand-to-end-of-visual-line ()
  "Set mark and move to end of visual line"
  (interactive)
  (set-mark-command nil)
  (end-of-visual-line)
  )

(defun oht/kill-line-backward ()
  "Kill from the point to beginning of whole line"
  (interactive)
  (kill-line 0))

(defun oht/toggle-line-numbers ()
  "Toggles display of line numbers. Applies to all buffers."
  (interactive)
  (if (bound-and-true-p display-line-numbers-mode)
      (global-display-line-numbers-mode -1)
    (global-display-line-numbers-mode)))

(defun oht/toggle-whitespace ()
  "Toggles display of indentation and space characters."
  (interactive)
  (if (bound-and-true-p whitespace-mode)
      (whitespace-mode -1)
    (whitespace-mode)))

(defun oht/open-line-below (arg)
  "Open a new indented line below the current one."
  (interactive "p")
  (end-of-line)
  (open-line arg)
  (next-line 1)
  (indent-according-to-mode))

(defun oht/open-line-above (arg)
  "Open a new indented line above the current one."
  (interactive "p")
  (beginning-of-line)
  (open-line arg)
  (indent-according-to-mode))

(defun oht/join-line-next ()
  (interactive)
  (join-line -1))

(defun oht/org-hide-emphasis-markers ()
  "Toggle whether or not the emphasis markers ~, =, *, _ are displayed"
  (interactive)
  (if (bound-and-true-p org-hide-emphasis-markers)
      (setq-local org-hide-emphasis-markers nil)
    (setq-local org-hide-emphasis-markers t))
  (font-lock-fontify-buffer)
  )

(defun oht/shell-command-on-region-replace (start end command)
  "Run shell-command-on-region interactivly replacing the region in place"
  (interactive (let (string)
                 (unless (mark)
                   (error "The mark is not set now, so there is no region"))
                 (setq string (read-from-minibuffer "Shell command on region: "
                                                    nil nil nil
                                                    'shell-command-history))
                 (list (region-beginning) (region-end)
                       string)))
  (shell-command-on-region start end command t t))
#+end_src

* Custom Minor Modes

/For future reference.../

You might want to think about creating a minor-mode you can call when switching to a new mode.

The below code is +stolen+ adapted from /prot/.

#+begin_example
(define-minor-mode oht/writing-mode
	“Explaination”
	:init-value nil
	:global nil
	(if oht/writing-mode
		(progn
		  (olivetti-mode 1)
		  (hl-line-mode 1)
		  (setq-local cursor-type ‘(bar . 4))
	  (olivetti-mode -1)
	  (hl-line-mode 1)
	  ((setq-local cursor-type ‘(bar . 2))))
#+end_example

* Mode Hooks

#+begin_src emacs-lisp

(defun oht/markdown-mode-hook ()
  (oht/writing-mode)
  )
(add-hook 'markdown-mode-hook 'oht/markdown-mode-hook)

(defun oht/org-mode-hook ()
  (oht/writing-mode)
  )
(add-hook 'org-mode-hook 'oht/org-mode-hook)

(defun oht/emacs-lisp-mode ()
  (outline-minor-mode t)
  (rainbow-delimiters-mode t)
  )
(add-hook 'emacs-lisp-mode 'oht/emacs-lisp-mode)

;; (defun oht/fountain-mode-hook ()
;;   (fountain-add-continued-dialog nil)
;;   (fountain-highlight-elements (quote (section-heading)))
;;   )
;; (add-hook 'fountain-mode 'oht/fountain-mode-hook)


#+end_src

* Hydra

Hydras should be reserved for mini-modes, /ie/ places where you'll want to call several functions in a row. If all you're doing is grouping similar commands then which-key should suffice.

** Text Manipulation

These commands pretty much require a region.

#+begin_src emacs-lisp
(defhydra hydra-manipulate (:color red)
  "Manipulate Text"
  ("|" oht/shell-command-on-region-replace "Pipe to shell" :color blue)
  ("j" oht/join-line-next "Join line with next")
  ("d" downcase-region "Downcase")
  ("u" upcase-region "Upcase")
  ("c" capitalize-region "Capitalise")
  ("s" sort-lines "Sort")
  ("-" delete-duplicate-lines "Del Dupes")
  ("q" nil "cancel" :color blue))
#+end_src

** Transpose
There are so many ways to transpose in Emacs, why not get help?

#+begin_src emacs-lisp
(defhydra hydra-transpose (:color red)
  "Transpose"
  ("c" transpose-chars "characters")
  ("w" transpose-words "words")
  ("o" org-transpose-words "Org mode words")
  ("l" transpose-lines "lines")
  ("s" transpose-sentences "sentences")
  ("e" org-transpose-elements "Org mode elements")
  ("p" transpose-paragraphs "paragraphs")
  ("t" org-table-transpose-table-at-point "Org mode table")
  ("q" nil "cancel" :color blue))
#+end_src

** Dired

#+begin_src emacs-lisp
;; dired commands
(defhydra hydra-dired (:hint nil :color pink)
  "
_+_ mkdir          _v_iew           _m_ark             _(_ details        _i_nsert-subdir    wdired
_C_opy             _O_ view other   _U_nmark all       _)_ omit-mode      _$_ hide-subdir    C-x C-q : edit
_D_elete           _o_pen other     _u_nmark           _l_ redisplay      _w_ kill-subdir    C-c C-c : commit
_R_ename           _M_ chmod        _t_oggle           _g_ revert buf     _e_ ediff          C-c ESC : abort
_Y_ rel symlink    _G_ chgrp        _E_xtension mark   _s_ort             _=_ pdiff
_S_ymlink          ^ ^              _F_ind marked      _._ toggle hydra   \\ flyspell
_r_sync            ^ ^              ^ ^                ^ ^                _?_ summary
_z_ compress-file  _A_ find regexp
_Z_ compress       _Q_ repl regexp

T - tag prefix
"
  ("\\" dired-do-ispell)
  ("(" dired-hide-details-mode)
  (")" dired-omit-mode)
  ("+" dired-create-directory)
  ("=" diredp-ediff)         ;; smart diff
  ("?" dired-summary)
  ("$" diredp-hide-subdir-nomove)
  ("A" dired-do-find-regexp)
  ("C" dired-do-copy)        ;; Copy all marked files
  ("D" dired-do-delete)
  ("E" dired-mark-extension)
  ("e" dired-ediff-files)
  ("F" dired-do-find-marked-files)
  ("G" dired-do-chgrp)
  ("g" revert-buffer)        ;; read all directories again (refresh)
  ("i" dired-maybe-insert-subdir)
  ("l" dired-do-redisplay)   ;; relist the marked or singel directory
  ("M" dired-do-chmod)
  ("m" dired-mark)
  ("O" dired-display-file)
  ("o" dired-find-file-other-window)
  ("Q" dired-do-find-regexp-and-replace)
  ("R" dired-do-rename)
  ("r" dired-do-rsynch)
  ("S" dired-do-symlink)
  ("s" dired-sort-toggle-or-edit)
  ("t" dired-toggle-marks)
  ("U" dired-unmark-all-marks)
  ("u" dired-unmark)
  ("v" dired-view-file)      ;; q to exit, s to search, = gets line #
  ("w" dired-kill-subdir)
  ("Y" dired-do-relsymlink)
  ("z" diredp-compress-this-file)
  ("Z" dired-do-compress)
  ("q" nil)
  ("." nil :color blue))

(define-key dired-mode-map "." 'hydra-dired/body)
#+end_src

** Buffer Menu

#+begin_src emacs-lisp
;; Buffer-menu
(defhydra hydra-buffer-menu (:color pink
                                    :hint nil)
  "
^Mark^             ^Unmark^           ^Actions^          ^Search
^^^^^^^^-----------------------------------------------------------------
_m_: mark          _u_: unmark        _x_: execute       _R_: re-isearch
_s_: save          _U_: unmark up     _b_: bury          _I_: isearch
_d_: delete        ^ ^                _g_: refresh       _O_: multi-occur
_D_: delete up     ^ ^                _T_: files only: % -28`Buffer-menu-files-only
_~_: modified
"
  ("m" Buffer-menu-mark)
  ("u" Buffer-menu-unmark)
  ("U" Buffer-menu-backup-unmark)
  ("d" Buffer-menu-delete)
  ("D" Buffer-menu-delete-backwards)
  ("s" Buffer-menu-save)
  ("~" Buffer-menu-not-modified)
  ("x" Buffer-menu-execute)
  ("b" Buffer-menu-bury)
  ("g" revert-buffer)
  ("T" Buffer-menu-toggle-files-only)
  ("O" Buffer-menu-multi-occur :color blue)
  ("I" Buffer-menu-isearch-buffers :color blue)
  ("R" Buffer-menu-isearch-buffers-regexp :color blue)
  ("c" nil "cancel")
  ("v" Buffer-menu-select "select" :color blue)
  ("o" Buffer-menu-other-window "other-window" :color blue)
  ("q" quit-window "quit" :color blue))
#+end_src

** Window Management

#+begin_src emacs-lisp
(defhydra hydra-windows (:color red)
  "Windows & Splits"
  ("<tab>" other-window "Cycle active window")
  ("v" (lambda ()
         (interactive)
         (split-window-right)
         (windmove-right) )"Vertical Split")
  ("s" (lambda ()
         (interactive)
         (split-window-below)
         (windmove-down)) "Split, Horizonal")
  ("o" delete-other-windows "Only This Window" :color blue)
  ("k" delete-window "Delete Window")
  ("r" oht/toggle-window-split "Rotate Window Split")
  ("b" balance-windows "Balance")
  ("[" shrink-window "Smaller VERT")
  ("]" enlarge-window "Bigger VERT")
  ("{" shrink-window-horizontally "Smaler HORZ")
  ("}" enlarge-window-horizontally "Bigger HORZ")
  ("<up>" windmove-up "Move UP")
  ("<down>" windmove-down "Move DOWN")
  ("<left>" windmove-left "Move LEFT")
  ("<right>" windmove-right "Move RIGHT")
  ("q" nil "cancel" :color blue))
#+end_src

** Vim-ish

I don't really want to use =evil-mode=. It does too much for my taste. I much prefer this simpler solution.

#+begin_src emacs-lisp
;; VIM-POWER functions
(defun hydra-modal/pre ()
  "When activating the hydra-modal, change the cursor to a box"
  (set-default 'cursor-type 'box))

(defun hydra-modal/post ()
  "When exiting the hydra-modal, change the cursor to a bar"
  (set-default 'cursor-type 'bar))

;; VIM-ISH HYDRA!
;; Since the color is set to amaranth, only actions labeled :blue will quit
(defhydra hydra-modal (:hint none :pre hydra-modal/pre :post hydra-modal/post :color amaranth)
  "
>>> VIM-ISH POWER ~ it's like vim, sort-of <<<"
  ("h" backward-char "left")
  ("l" forward-char "right")
  ("j" next-line "next")
  ("k" previous-line "previous")
  ("C-h" backward-word "previous word")
  ("C-l" forward-word "end of next word")
  ("C-k" backward-paragraph "back paragraph")
  ("C-j" forward-paragraph "forward paragraph")
  ("J" oht/join-line-next "join")
  ("u" beginning-of-visual-line "start of line")
  ("p" end-of-visual-line "end of line")
  ("P" yank "paste")
  ("[" scroll-down-line "scroll line up")
  ("]" scroll-up-line"scroll line down")
  ("{" scroll-down-command "scroll up")
  ("}" scroll-up-command "scroll down")
  ("o" exchange-point-and-mark "swap point/mark")
  ("v" set-mark-command "mark")
  ("V" oht/mark-whole-line "mark whole line")
  ("C-v" rectangle-mark-mode "rectangle mark")
  ("<DEL>" kill-region "kill region")
  ("d" kill-region "kill region")
  ("x" delete-char "delete-char")
  ("c" kill-region "change" :color blue)
  ("z" recenter-top-bottom "cycle recenter")
  ("s-z" undo-tree-undo "undo")
  ("s-Z" undo-tree-redo "redo")
  ("s-x" kill-region "cut")
  ("s-c" kill-ring-save "copy")
  ("s-v" yank "paste")
  ("I" beginning-of-visual-line "append" :color blue)
  ("a" forward-char "append" :color blue)
  ("A" end-of-visual-line "append line" :color blue)
  ("s-j" nil "cancel" :color blue)
  ("i" nil "cancel" :color blue))
#+end_src

** Spelling

#+begin_src emacs-lisp
(defun hydra-flyspell/pre ()
  ;;(flyspell-mode t)
  )

(defhydra hydra-flyspell (:pre hydra-flyspell/pre :color red)
  "Spelling"
  (";" flyspell-goto-next-error "Next")
  (":" flyspell-correct-word-before-point "Correct")
  ("q" nil "cancel" :color blue))
#+end_src

** Org-Agenda

#+begin_src emacs-lisp
(defhydra hydra-org-agenda-filter (:color red)
  "Filter org-agenda"
  ("/" org-agenda-filter "filter")
  ("c" org-agenda-filter-by-category "category")
  ("r" org-agenda-filter-by-regexp "regexp")
  ("t" org-agenda-filter-by-tag "tag")
  ("h" org-agenda-filter-by-top-headlines "headlines")
  ("e" org-agenda-filter-by-effort "effort")
  ("|" org-agenda-filter-remove-all "remove")
  ("q" nil "cancel" :color blue))

;; You have to wait until org-agenda loads because org itself
;; doesn't know what 'org-agenda-mode-map' is.
(eval-after-load "org-agenda"
'(progn
	(define-key org-agenda-mode-map
		"." 'hydra-org-agenda-filter/body)
		))
#+end_src

** Org-Agenda View Toggle

This is beautiful. It is taken from [[https://oremacs.com/2016/04/04/hydra-doc-syntax/][abo-abo]] (creator of hydra). It creates view toggles and displays the status of those toggles.

#+begin_src emacs-lisp
;; You have to wait until org-agenda loads because org itself
;; doesn't know what 'org-agenda-mode-map' is.
(eval-after-load "org-agenda"
'(progn
	(define-key org-agenda-mode-map
		"v" 'hydra-org-agenda-view/body)
		))

(defun org-agenda-cts ()
  (let ((args (get-text-property
               (min (1- (point-max)) (point))
               'org-last-args)))
    (nth 2 args)))
(defhydra hydra-org-agenda-view (:hint none)
  "
_d_: ?d? day        _g_: time grid=?g? _a_: arch-trees
_w_: ?w? week       _[_: inactive      _A_: arch-files
_t_: ?t? fortnight  _f_: follow=?f?    _r_: report=?r?
_m_: ?m? month      _e_: entry =?e?    _D_: diary=?D?
_y_: ?y? year       _q_: quit          _L__l__c_: ?l?"
  ("SPC" org-agenda-reset-view)
  ("d" org-agenda-day-view
   (if (eq 'day (org-agenda-cts))
       "[x]" "[ ]"))
  ("w" org-agenda-week-view
   (if (eq 'week (org-agenda-cts))
           "[x]" "[ ]"))
  ("t" org-agenda-fortnight-view
       (if (eq 'fortnight (org-agenda-cts))
           "[x]" "[ ]"))
  ("m" org-agenda-month-view
       (if (eq 'month (org-agenda-cts)) "[x]" "[ ]"))
  ("y" org-agenda-year-view
       (if (eq 'year (org-agenda-cts)) "[x]" "[ ]"))
  ("l" org-agenda-log-mode
       (format "% -3S" org-agenda-show-log))
  ("L" (org-agenda-log-mode '(4)))
  ("c" (org-agenda-log-mode 'clockcheck))
  ("f" org-agenda-follow-mode
       (format "% -3S" org-agenda-follow-mode))
  ("a" org-agenda-archives-mode)
  ("A" (org-agenda-archives-mode 'files))
  ("r" org-agenda-clockreport-mode
       (format "% -3S" org-agenda-clockreport-mode))
  ("e" org-agenda-entry-text-mode
       (format "% -3S" org-agenda-entry-text-mode))
  ("g" org-agenda-toggle-time-grid
       (format "% -3S" org-agenda-use-time-grid))
  ("D" org-agenda-toggle-diary
       (format "% -3S" org-agenda-include-diary))
  ("!" org-agenda-toggle-deadlines)
  ("["
   (let ((org-agenda-include-inactive-timestamps t))
     (org-agenda-check-type t 'timeline 'agenda)
     (org-agenda-redo)))
  ("q" (message "Abort") :exit t))
#+end_src

* Keybindings

***  Keybindings Philosophy

1. Standard mac shortcuts should be supported wherever possible. And since mac inherits a lot of emacs keybindings anyway (and I use them outside emacs) I can leverage a lot of muscle memory. Additionally, I've largely internalized the =readline= keybindings (since I worked in =vim= for a long time) and so =^w=, =^u=, and =^h= are second-nature.

2. Enhance Emacs built-in bindings with improved alternatives. For example, I've replaced =^s= with =swiper-isearch=. So the binding still does the same thing, just better.

3. Global Leader - I borrow the concept of a "leader key" from vim and put every custom function I can there. This prevents conflicts with existing bindings and, since I'm using which-key, helps me remember the possibilities.

4. Mode Leader - All mode-spesific bindings (for example org-time-stamp), which don't make any sense elsewhere should go behind a uniform mode-leader key.

5. Keybindings which I use all the time, get taken out from behind leaders for faster access. For example, the org-agenda command.

*** Standard Mac Shortcuts

[[https://support.apple.com/en-us/HT201236]]

#+begin_src emacs-lisp
(define-key key-translation-map (kbd "ESC") (kbd "C-g"))
(global-set-key (kbd "s-,") 'oht/counsel-find-settings)
(global-set-key (kbd "s-n") 'make-frame-command)
(global-set-key (kbd "s-s") 'save-buffer)         ;save
(global-set-key (kbd "s-S") 'write-file)          ;save as
(global-set-key (kbd "M-s-s") 'save-some-buffers) ;save others
(global-set-key (kbd "s-o") 'counsel-find-file)
(global-set-key (kbd "M-s-o") 'counsel-buffer-or-recentf)
(global-set-key (kbd "s-z") 'undo-tree-undo)
(global-set-key (kbd "s-Z") 'undo-tree-redo)
(global-set-key (kbd "s-x") 'kill-region)
(global-set-key (kbd "s-c") 'kill-ring-save)
(global-set-key (kbd "s-v") 'yank)
(global-set-key (kbd "s-<backspace>") 'oht/kill-line-backward)
(global-set-key (kbd "s-q") 'save-buffers-kill-terminal)
(global-set-key (kbd "s-/") 'comment-line)
(global-set-key (kbd "s-<up>") (kbd "M-<"))
(global-set-key (kbd "s-<down>") (kbd "M->"))
(global-set-key (kbd "s-l") 'oht/mark-whole-line)
(global-set-key (kbd "s-M-l") 'mark-paragraph)
(global-set-key (kbd "s-]") 'indent-rigidly-right-to-tab-stop)
(global-set-key (kbd "s-[") 'indent-rigidly-left-to-tab-stop)
(global-set-key (kbd "S-s-<left>") 'oht/expand-to-beginning-of-visual-line)
(global-set-key (kbd "S-s-<right>") 'oht/expand-to-end-of-visual-line)
(global-set-key (kbd "s-f") 'swiper)
(global-set-key (kbd "M-s-f") 'swiper-all)
(global-set-key (kbd "S-s-f") 'counsel-ag)
(global-set-key (kbd "s-<return>") 'oht/open-line-below)
(global-set-key (kbd "S-s-<return>") 'oht/open-line-above)
(global-set-key (kbd "M-s-<right>") 'next-buffer)
(global-set-key (kbd "M-s-<left>") 'previous-buffer)
; Mac follows the UNIX convention of C-h being the same as <DEL>
(global-set-key (kbd "C-h") 'delete-backward-char)
;; Normally, C-? is used for undo/redo,
;; but I've rebound that elsewhere, so I can use it here
(bind-key* "C-?" 'help-command)
;; readline-style shortcuts, because I love them
(global-set-key (kbd "C-w") 'backward-kill-word)
(global-set-key (kbd "C-u") 'oht/kill-line-backward)
;; No reason not to use command-u for this
(global-set-key (kbd "s-u") 'universal-argument)
#+end_src

*** Enhance Emacs

#+begin_src emacs-lisp
(global-set-key (kbd "C-s") 'swiper-isearch)
(global-set-key (kbd "C-r") 'swiper-isearch-backward)
(global-set-key (kbd "M-/") 'hippie-expand)
(global-set-key (kbd "M-t") 'hydra-transpose/body)
(global-set-key (kbd "M-y") 'counsel-yank-pop)
(global-set-key (kbd "M-<up>") 'move-line-up)
(global-set-key (kbd "M-<down>") 'move-line-down)
(global-set-key (kbd "M-o") 'other-window)
(global-set-key (kbd "M-z") 'zap-up-to-char) ;the default is 'zap-to-char
#+end_src

This cycles the spacing around point between a single space, no spaces, or the original spacing:

#+begin_src emacs-lisp
(global-set-key (kbd "M-SPC") 'cycle-spacing)
#+end_src

*** Primary Bindings

#+begin_src emacs-lisp
(global-set-key (kbd "s-a") 'org-agenda)
(global-set-key (kbd "s-p") 'counsel-M-x)
(global-set-key (kbd "s-b") 'counsel-ibuffer)
(global-set-key (kbd "M-s-b") 'ibuffer)
(bind-key* "s-e" er/expand-region)
(global-set-key (kbd "s-m") 'magit-status)
;; vim has the wonderful . command, and emacs has repeat
;; s-y is my keybinding because excel has (a version of) repeat bound to that
(bind-key "s-y" 'repeat)
(global-set-key (kbd "s-j") 'hydra-modal/body)
(global-set-key (kbd "s-w") 'hydra-windows/body)
(global-set-key (kbd "s-;") 'hydra-flyspell/body)
(global-set-key (kbd "s-|") 'hydra-manipulate/body)
#+end_src

*** Global Leader Bindings

I use =⌘-'= as the my leader.

#+begin_src emacs-lisp
(global-set-key (kbd "s-' a") 'counsel-ag)
(global-set-key (kbd "s-' b") 'counsel-descbinds)
(global-set-key (kbd "s-' c") 'org-capture)
(global-set-key (kbd "s-' d") 'sdcv-search)
(global-set-key (kbd "s-' f") 'oht/counsel-find-org)
(global-set-key (kbd "s-' h") 'hl-line-mode)
(global-set-key (kbd "s-' k") 'oht/kill-this-buffer)
(global-set-key (kbd "s-' l") 'oht/toggle-line-numbers)
(global-set-key (kbd "s-' o") 'counsel-outline)
(global-set-key (kbd "s-' s-o") 'counsel-org-goto-all)
(global-set-key (kbd "s-' w") 'oht/toggle-whitespace)
#+end_src

*** Mode Spesific Bindings

I use =⌘-\= as the leader for mode-spesific bindings.

#+begin_src emacs-lisp
(with-eval-after-load 'org
  (define-key org-mode-map (kbd "s-\\ v") 'oht/fix-variable-org-indent)
  (define-key org-mode-map (kbd "s-\\ .") 'org-time-stamp)
  (define-key org-mode-map (kbd "s-\\ t") 'org-todo)
  (define-key org-mode-map (kbd "s-\\ s-t") 'counsel-org-tag)
  (define-key org-mode-map (kbd "s-\\ n") 'org-narrow-to-subtree)
  (define-key org-mode-map (kbd "s-\\ w") 'widen)
  (define-key org-mode-map (kbd "s-\\ s") 'org-search-view)
  (define-key org-mode-map (kbd "s-\\ <") 'org-insert-structure-template)
  (define-key org-mode-map (kbd "s-\\ l") 'org-store-link)
  (define-key org-mode-map (kbd "s-\\ i") 'org-insert-last-stored-link)
  (define-key org-mode-map (kbd "s-\\ m") 'oht/org-hide-emphasis-markers)
  )

;; buffer menu bindings
(define-key Buffer-menu-mode-map "." 'hydra-buffer-menu/body)
#+end_src
