#+TITLE: Emacs Settings & Configuration
#+AUTHOR: Oliver Taylor

* Hello!

/Welcome!/ I'm sorry, but I'm not writing this for you, I'm writing this for me---well, /future/-me. I don't want to forget how this configuration file works, or why I did things this way, so I write it in [[https://en.wikipedia.org/wiki/Literate_programming][this format]] so I can read it later and understand what the hell /past/-me was thinking.

** What is This?

This document does 2 things simultaneously, it is both the configuration file containing all my settings and preferences that Emacs reads when it starts-up /and/ it is a document that's meant to be read by a human which explains what the configuration and settings do and why I want them done that way.

This file is called =emacs-init.org= and to make it work, you need the following in your =~/.emacs.d/init.el=:

#+begin_example
(require 'org)
(org-babel-load-file (expand-file-name "~/dot/emacs/emacs-init.org"))
#+end_example

** My Emacs Philosophy

1. Using Emacs makes no sense unless you customize it extensively. If you're not interested in, or don't want to bother with, customizing Emacs to the point where it molds around what you expect of it (rather than requiring /you to mold to it/) then save yourself the trouble and use another editor, there are a lot of great ones.

2. Accept that you will never remember Emacs keybindings, and that even if you do it will injure your pinky, and don't even bother trying. That's not a down-side, it means you don't have to learn anything new (!), just learn to make Emacs work the way you expect it to. That sounds like it might be difficult, but once you get the hang of customizing Emacs it becomes easy.

3. There's a few things you should learn to use in order to learn about Emacs's capabilities. Poke around =C-h ?= for Help. Use =M-x= to explore. Use =which-key= to give you hints for difficult to remember shortcuts.

4. Use =hydra= to set up what are basically "mini-modes". I don't know how I'd function without the one I have setup for window management. And the vim-ish hydra below is very useful indeed. As the saying goes "the best editor is not vim or emacs, but both".

** Keybindings Philosophy

1. Standard mac shortcuts should be supported wherever possible. And since mac inherits a lot of emacs keybindings anyway (and I use them outside emacs) I can leverage a lot of muscle memory. Additionally, I've largely internalized the =readline= keybindings (since I worked in =vim= for a long time) and so =^w=, =^u=, and =^h= are second-nature.

2. Enhance Emacs built-in bindings with improved alternatives. For example, I've replaced =^s= and =^r= with =ctrlf-=. So the binding still does the same thing, just better.

3. Global Leader - I borrow the concept of a "leader key" from vim and use it as a dumping ground for my most important commands, which don't have mac or Emacs equivalents.

4. Mode Leader - All mode-spesific bindings (for example org-time-stamp), which don't make any sense in any other mode go behind a uniform mode-leader key. I've picked =s-\=.

5. Keybindings which I use all the time, get taken out from behind leaders for faster access. For example, the org-agenda command.

** Inspiration and References

Anyone learning vim, emacs, zsh, bash, or something similar, spends a lot of time looking at other people's configuration files (much like this one). I've learned from some wonderful (and well documented) examples. Here is a list of the ones I've learned the most from:

- [[https://protesilaos.com/dotemacs/][Protesilaos Stavrou Dotemacs]]
- [[https://github.com/oantolin/emacs-config/blob/master/init.el][Oantolin emacs config]]
- [[https://blog.aaronbieber.com][Aaron Bieber, Blog & Dotfiles]]
- [[https://github.com/hrs/dotfiles/blob/main/emacs/dot-emacs.d/configuration.org][Harry R. Schwartz dotfiles]]
- [[https://yiufung.net/post/org-mode-hidden-gems-pt1/][Org-Mode Hidden Gems]]
- [[https://github.com/angrybacon/dotemacs/blob/master/dotemacs.org][Angry Bacon dotemacs]]
- [[https://gitlab.com/Kaligule/emacs-config/-/blob/master/config.org][Kaligule config.org]]
- [[https://github.com/andschwa/.emacs.d][Andrew Schwartzmeyerâ€™s Emacs configurations]]
- [[https://github.com/raxod502/radian][Radian]]

For more sources see [[https://pinboard.in/u:Oliver/t:emacs][my pinboard bookmarks]].

** How This Document is Organized

I used to organize this document by type of customization---keybindings together, functions together, packages together, etc.---but have switched to a topic-based organization.

*#hotTip:* When picking binding for a new command, check =describe-personal-keybindings= first.

* Installation

First, make sure you're using the correct version. I like [[https://bitbucket.org/mituharu/emacs-mac/raw/892fa7b2501a403b4f0aea8152df9d60d63f391a/README-mac][Mitsuharu Yamamoto's Emacs fork]] because it provides [[https://bitbucket.org/mituharu/emacs-mac/src/f3402395995bf70e50d6e65f841e44d5f9b4603c/README-mac?at=master&fileviewer=file-view-default][a lot of nice stuff]] for people who want their Emacs to be a better macOS citizen.

* Settings

** Emacs Startup

As recommended in Radian...

#+begin_src emacs-lisp
;; Disable frequency of GC. This helps performance both during init
;; and after init. Value is in bytes so this is 100MB, as suggested in
;; <https://github.com/emacs-lsp/lsp-mode#performance>.
(setq gc-cons-threshold (* 100 1024 1024))
#+end_src

This tells emacs to startup with a scratch buffer, with custom content, and to do it quietly.

#+begin_src emacs-lisp
(setq initial-scratch-message
      (concat
       ";; This buffer is for text that is not saved, and for Lisp evaluation.\n"
       ";; To create a file, visit it with C-x C-f and enter text in its buffer.\n"
       ";; WELCOME TO EMACS\n"))
(setq inhibit-splash-screen t
      inhibit-startup-message t
      inhibit-startup-echo-area-message t)
#+end_src

** Encoding

Set encoding to be UTF-8 everywhere. [[https://www.masteringemacs.org/article/working-coding-systems-unicode-emacs][Mastering Emacs has more info]].

#+begin_src emacs-lisp
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
;; backwards compatibility as default-buffer-file-coding-system
;; is deprecated in 23.2.
(if (boundp 'buffer-file-coding-system)
    (setq-default buffer-file-coding-system 'utf-8)
  (setq default-buffer-file-coding-system 'utf-8))

;; Treat clipboard input as UTF-8 string first; compound text next, etc.
(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
#+end_src

** Customizing

When customizing Emacs interactively (ie: not in this document or =init.el=) Emacs appends code to your =init.el= file, which can be annoying when editing it by hand. This tells Emacs to place these customizations in a separate file.

#+begin_src emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(when (file-exists-p custom-file)
  (load custom-file :noerror))
#+end_src

** emacs.d Folder Layout

This tells emacs how I've laid-out by emacs directory.

#+begin_src emacs-lisp
(add-to-list 'custom-theme-load-path (expand-file-name "themes" user-emacs-directory))
(setq backup-directory-alist `(("." . "~/.emacs.d/saves")))
#+end_src

Emacs can automatically create backup files. This tells Emacs to put all backups in =~/.emacs.d/backups=. [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Backup-Files.html][More info]].

#+begin_src emacs-lisp
(setq backup-directory-alist `(("." . ,(concat user-emacs-directory
                                               "backups"))))
#+end_src

I have a bunch of misc custom functions that I keep in a separate file to make this document a little cleaner.

#+begin_src emacs-lisp
(load "~/dot/emacs/functions.el")
#+end_src

** General

#+begin_src emacs-lisp
(global-auto-revert-mode t)           ; update buffer when file on disk changes
;;(desktop-save-mode 1)                 ; sessions
(save-place-mode 1)                   ; reopens the file to the same spot you left
(recentf-mode 1)                      ; enables "Open Recent..." in file menu
(setq tab-width 4)                    ; tabs=4 char
(setq help-window-select t)           ; focus new help windows when opened
(setq sentence-end-double-space nil)  ; ends sentence after 1 space
(fset 'yes-or-no-p 'y-or-n-p)         ; Changes all yes/no questions to y/n type
(setq create-lockfiles nil)           ; No need for ~ files when editing
(setq confirm-kill-emacs 'yes-or-no-p) ; Ask if you really want to quit
#+end_src

Use the system trash folder to delete files.

#+begin_src emacs-lisp
(setq delete-by-moving-to-trash t)
(setq trash-directory "~/.Trash/emacs")
#+end_src

If I ever accidentally kill the scratch buffer, just bury it instead.

#+begin_src emacs-lisp
(defadvice kill-buffer (around kill-buffer-around-advice activate)
  (let ((buffer-to-kill (ad-get-arg 0)))
    (if (equal buffer-to-kill "*scratch*")
        (bury-buffer)
      ad-do-it)))
#+end_src

* Spelling

Tell ispell where to find the =aspell= executable, and some settings.

#+begin_src emacs-lisp
(setq ispell-program-name "/usr/local/bin/aspell")
(customize-set-variable 'ispell-extra-args '("--sug-mode=ultra"))
(setq ispell-list-command "list")
#+end_src

** Flyspell-Correct

=flyspell-correct= allows you to pass spelling suggestions to completion and search frameworks, such as =selectrum=. This setup code is copied directly from the selectrum documentation.

#+begin_src emacs-lisp
(use-package flyspell-correct
  :custom
  (flyspell-correct-interface 'flyspell-correct-dummy)
)
(advice-add 'flyspell-correct-dummy :around
	    (defun my--fsc-wrapper (func &rest args)
	      (let ((selectrum-should-sort-p nil))
		(apply func args))))
#+end_src

** Spelling Hydra

#+begin_src emacs-lisp
(defun hydra-flyspell/pre ()
  ;;(flyspell-mode t)
  )

(defhydra hydra-flyspell (:pre hydra-flyspell/pre :color red)
  "Spelling"
  (";" flyspell-goto-next-error "Next")
  (":" flyspell-correct-at-point "Correct")
  ("q" nil "cancel" :color blue))

(bind-key "s-;" 'hydra-flyspell/body)
#+end_src

* Emacs Help

=helpful= is a really neat package that brings together a lot of useful information when you ask Emacs for help.

#+begin_src emacs-lisp
(use-package helpful
  ;; https://github.com/Wilfred/helpful
  :bind
  ("C-h f" . #'helpful-callable)
  ("C-h F" . #'helpful-function)
  ("C-h v" . #'helpful-variable)
  ("C-h k" . #'helpful-key)
  ("C-h C" . #'helpful-command)
 )

;; Normally, C-? is used for undo/redo,
;; but I've rebound that elsewhere, so I can use it here
(bind-key* "C-?" 'help-command)
(bind-key* "s-/" 'help-command)
#+end_src

* macOS Consistency

The below is probably the biggest reason why I managed get over the intimidation of using Emacs in those first few days.

** Modifiers & Emacs Anachronisms

The below does 3 things:

1. Makes the command keys act as =super=. =super= keybindings are basically not used by Emacs so they're a safe playground for assigning your own keybindings. I setup =s-q= for quit,  =s-s= for save, =s-z= for undo, =s-o= for open file, basically, all the standard Mac shortcuts. Once I did that Emacs became very usable immediately and that ease-of-use made learning Emacs a lot less painful.
2. Makes the left option key act =meta= so I can use meta-keybindings.
3. Makes the right option key act as =option= to I can insert characters like: Â£Â¢âˆžÂ§Â¶â€¢â‰ ï£¿.

#+begin_src emacs-lisp
(setq mac-command-modifier 'super)
(setq mac-option-modifier 'meta)
(setq mac-right-option-modifier 'nil)
#+end_src

Due to historical reasons, Emacs thinks =C-i= is the same as =TAB= and =C-m= is the same as =RETURN=. The below undoes that assumption. This will allow you to re-bind them later.

#+begin_src emacs-lisp
(define-key input-decode-map [?\C-i] [C-i])
(bind-key "<C-i>" nil)
(define-key input-decode-map [?\C-m] [C-m])
(bind-key "<C-m>" nil)
#+end_src

By default, Emacs doesn't replace the selection (region) with anything you type, it just removes your selection and appends what you type. The below makes what you type /replace/ your selection.

#+begin_src emacs-lisp
(delete-selection-mode t)
#+end_src

When editing 2 files with the same name, like =~/foo/file= and =~/bar/file=, Emacs (amazingly) refers to those files as =file<~/foo>= and =file<~/bar>=. This makes Emacs refer to them as =foo/file= and =bar/file=, like a sane program.

#+begin_src emacs-lisp
;;(require 'uniquify)
(setq uniquify-buffer-name-style 'forward)
#+end_src

By default Emacs window sizes always line-up with the character-grid, meaning the windows resize only by character-widths and line-heights. This setting allows the windows to be unconstrained by the grid, thus resize smoothly.

#+begin_src emacs-lisp
(setq frame-resize-pixelwise t)
#+end_src

When no region is active (nothing is selected), and you invoke the =kill-region= (cut) or =kill-ring-save= (copy) commands, Emacs acts on the range of characters between the mark and the point. This is a really good way to accidentally kill half your document. I have done this more times than I'd like to admit.

The below code changes the =kill-region= and =kill-ring-save= commands so that, without a selection, they act on the current line instead of the range between mark and point. It also, helpfully, prints a message saying what it did.

#+begin_src emacs-lisp
(defadvice kill-ring-save (before slick-copy activate compile)
  "When called interactively with no active region, copy a single line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (message "Copied line")
     (list (line-beginning-position)
	   (line-beginning-position 2)))))

(defadvice kill-region (before slick-cut activate compile)
  "When called interactively with no active region, kill a single line instead."
  (interactive
    (if mark-active (list (region-beginning) (region-end))
      (message "Killed line")
      (list (line-beginning-position)
	    (line-beginning-position 2)))))
#+end_src

** Visual Line Mode

Visual line mode is super helpful, but out-of-the-box movement commands behave inconsistently with the rest of macOS, so the below code brings them back in line.

#+begin_src emacs-lisp
;; Turn on word-wrap globally
(global-visual-line-mode t)
;; with visual-line-mode set,
;; C-a and C-b go to beginning/end-of-visual-line
;; which is inconsistant with standard Mac behaviour
(bind-key* "C-a" 'beginning-of-line)
(bind-key* "C-e" 'end-of-line)
(bind-key "s-<left>" 'beginning-of-visual-line)
(bind-key "s-<right>" 'end-of-visual-line)
;; C-k only killing the visual line also isn't how macOS works.
;; This has to be set to a custom function so minor modes can't hijack it.
(bind-key* "C-k" 'oht/kill-line)
#+end_src

** Standard Mac Shortcuts

Wherever possible I want to use standard [[https://support.apple.com/en-us/HT201236][macOS shortcuts]]. macOS actually inherits many Emacs keybindings, but adds to it a few from =readline= and old terminal interfaces. Because these are available system-wide I want Emacs to do the same thing. That way the way I type/move in Mail.app or Safari is the same as Emacs. There are also conventions that, while not officially standard, have become widely accepted, those should be respected too. Some of these require custom functions, but that's usually a simple matter of stringing a couple existing commands together into a function.

#+begin_src emacs-lisp
;; in emacs <del/backspace> is backward-delete and <delete> is forward-delete
;; and by default option+forward-delete has no mapping
(bind-key "M-<delete>" 'kill-word)
;; C-[ sends ESC so let's make ESC more predictable
(define-key key-translation-map (kbd "ESC") (kbd "C-g"))
(bind-keys
 ("s-," . oht/find-settings)
 ("s-n" . make-frame-command)
 ("s-t" . oht/new-tab)
 ("s-m" . iconify-frame)
 ("s-s" . save-buffer)
 ("s-S" . write-file)			;save as
 ("s-a" . mark-whole-buffer)
 ("s-o" . find-file)
 ("s-z" . undo-tree-undo)
 ("s-Z" . undo-tree-redo)
 ("s-x" . kill-region)
 ("s-c" . kill-ring-save)
 ("s-v" . yank)
 ("s-<backspace>" . oht/kill-visual-line-backward)
 ("s-w" . delete-frame)
 ("s-q" . save-buffers-kill-terminal)
 ("s-l" . oht/mark-whole-line)
 ("s-M-l" . mark-paragraph)
 ("s-]" . indent-rigidly-right-to-tab-stop)
 ("s-[" . indent-rigidly-left-to-tab-stop)
 ("S-s-<left>" . oht/expand-to-beginning-of-visual-line)
 ("S-s-<right>" . oht/expand-to-end-of-visual-line)
 ("s-<return>" . oht/open-line-below)
 ("S-s-<return>" . oht/open-line-above)
 )
;; these don't work with 'bind-keys' (above)
(bind-key "s-<up>" (kbd "M-<"))
(bind-key "s-<down>" (kbd "M->"))
;; Use same shortcuts as tab-movement for buffer movement
(bind-key "s-}" 'next-buffer)
(bind-key "s-{" 'previous-buffer)
;; Mac follows the UNIX convention of C-h being the same as <DEL>
(bind-key* "C-h" 'delete-backward-char)
;; readline-style shortcuts, because I love them
(bind-key* "C-w" 'backward-kill-word)
(bind-key "C-u" 'oht/kill-line-backward)
;; No reason not to use command-u for this
(bind-key "s-u" 'universal-argument)
;; since ctrl+alt+b/f are system shortcuts for word movement, do that
(bind-key* "C-M-b" 'left-word)
(bind-key* "C-M-f" 'right-word)
;; respect alt+forward-delete
(bind-key* "M-<delete>" 'kill-word)
#+end_src

* Narrowing & Searching

Navigating and using the thousands of things Emacs can do is built around the idea of searching and narrowing a selection down to the thing you're looking for. To make this easier I've installed a few packages that enhance Emacs built-in facilities for doing this.

I've tried a number of them (including =ivy=, =helm=, and =icomplete=) but I find =selectrum= to be the most Emacs-y (in a good way). It is very simple, very fast, and doesn't try to do more than its basic function.

#+begin_src emacs-lisp
;; selectrum is the live-search framework
(use-package selectrum
  :config (selectrum-mode +1)
  :bind
  ("s-b" . selectrum-switch-buffer+)
  ("M-y" . yank-pop+)
  ("M-s-o" . recentf-open-files+)
  )

;; prescient is for sorting search candidates
(use-package prescient
  :config (prescient-persist-mode +1)
  )

;; this combines them
(use-package selectrum-prescient
  :config (selectrum-prescient-mode +1)
)

;; this sublime package makes it so your fuzzy searches can be out of order
;; which is extremely useful when searching thousands of candidates (m-x)
(use-package orderless
  :custom (completion-styles '(orderless)))
#+end_src

The creator of these packages also created an enhanced version of =isearch= which I find very useful, and in keeping with the philosophy of minimalism.

#+begin_src emacs-lisp
(use-package ctrlf
  :config (ctrlf-mode +1)
  ;; C-s - ctrlf-forward-literal
  ;; C-r - ctrlf-backward-literal
  ;; C-M-s - ctrlf-forward-regexp
  ;; C-M-r - ctrlf-backward-regexp
  ;; M-s _ - ctrlf-forward-symbol
  ;; M-s . - ctrlf-forward-symbol-at-point
  ;; by default is only case-sensitive if search has uppercase letters
  ;; M-n inserts symbol-at-point
  ;; C-o s - change search style
  ;; see ctrlf-minibuffer-bindings
  )
#+end_src

* Packages

** General

#+begin_src emacs-lisp
;; make sure everything I declare is installed
(setq use-package-always-ensure t)

(use-package magit)
(use-package bind-key)
(use-package exec-path-from-shell)
(use-package multiple-cursors)
(use-package olivetti)
(use-package unfill)
(use-package use-package-chords
  :config
  (key-chord-mode 1)
  (key-chord-define-global ",." "<>\C-b"))
(use-package hydra
  :chords (("fj" . hydra-modal/body)))
(use-package which-key
  :config (which-key-mode t))
(use-package undo-tree
  :config (global-undo-tree-mode 1)
  :custom
  (undo-tree-visualizer-timestamps t "Show timestamps in the undo-tree.")
  (undo-tree-visualizer-diff t "Show a diff of changes for the current node.")
  ;; DO NOT be a fool and rebind "C-/", it will prevent you from enabling the global mode
  )
(use-package expand-region
  :bind
  ("s-e" . er/expand-region)
  ("s-E" . er/contract-region)
)
(use-package sdcv-mode
  :load-path "lisp/emacs-sdcv/")

(use-package buffer-move
  :bind
  ("M-s-<left>" . buf-move-left)
  ("M-s-<right>" . buf-move-right)
  ("M-s-<up>" . buf-move-up)
  ("M-s-<down>" . buf-move-down)
)

;; Winner Mode is built-in Since emacs seems to love spawning new
;; windows, and taking over your existing ones, this allows you to undo and redo those arrangements. So you if a command kills a window arrangement you were using you can go back to it with winner-undo and winner-redo.
(winner-mode 1)
#+end_src

** Modes

#+begin_src emacs-lisp
(use-package fountain-mode)
(use-package lua-mode)
(use-package markdown-mode
  :hook oht/writing-mode)
#+end_src

** Mode Hooks

*** Spelling

Flyspell offers on-the-fly spell checking. We can enable flyspell for all text-modes with this snippet.

#+begin_src emacs-lisp
(add-hook 'text-mode-hook 'turn-on-flyspell)
#+end_src

To use flyspell for programming there is flyspell-prog-mode, that only enables spell checking for comments and strings. We can enable it for all programming modes using the prog-mode-hook.

#+begin_src emacs-lisp
(add-hook 'prog-mode-hook 'flyspell-prog-mode)
#+end_src

*** General

#+begin_src emacs-lisp
(defun oht/org-mode-hook ()
  (oht/writing-mode)
  (undo-tree-mode)
  )
(defun oht/emacs-lisp-mode ()
  (undo-tree-mode)
  (outline-minor-mode t)
  (rainbow-delimiters-mode t)
  )
(add-hook 'emacs-lisp-mode 'oht/emacs-lisp-mode)

(defun oht/fountain-mode-hook ()
  (fountain-add-continued-dialog nil)
  (fountain-highlight-elements (quote (section-heading)))
  )
(add-hook 'fountain-mode 'oht/fountain-mode-hook)

(add-hook 'dired-mode-hook
          (lambda ()
            (dired-hide-details-mode 1)
	    (auto-revert-mode)
	  ))
#+end_src

* Appearance

** Display

#+begin_src emacs-lisp
(menu-bar-mode 1)                          ; ensures full-screen avail on macOS
(tool-bar-mode -1)                         ; hide menu-bar
(scroll-bar-mode -1)                       ; hide scroll bars
(show-paren-mode t)                        ; highlight parens
(setq show-paren-delay 0)                  ; and show immediately
(setq visible-bell t)                      ; disable beep
(setq-default frame-title-format '("%b"))  ; show buffer name in titlebar
(set-default 'cursor-type 'bar)            ; use bar here, box in modes
(setq x-underline-at-descent-line t)       ; underline at descent, not baseline
#+end_src

** Fonts

Here the fonts are setup in a function so I can change them all in once step by calling =oht/set-font=.

#+begin_src emacs-lisp
(defun oht/set-font ()
  (interactive)
  "These settings are placed inside a function so that I can set them all at once by calling the function."
  (set-face-attribute 'default nil
		      :family "Iosevka Fixed SS08" :height 140 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
		      :family "Iosevka Fixed SS08" :height 140 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
		      :family "IBM Plex Serif" :height 150 :weight 'normal)
  (set-face-attribute 'bold nil :weight 'semibold)
  )

(oht/set-font)
#+end_src

** Theme

I use, and *love* /prot/'s [[https://gitlab.com/protesilaos/modus-themes][Modus Themes]].

#+begin_src emacs-lisp
(use-package modus-vivendi-theme
  :defer t
  :custom
  (modus-vivendi-theme-faint-syntax t)
  (modus-vivendi-theme-slanted-constructs t)
  (modus-vivendi-theme-bold-constructs t)
  (modus-vivendi-theme-3d-modeline t))

(use-package modus-operandi-theme
  :custom
  (modus-operandi-theme-faint-syntax t)
  (modus-operandi-theme-slanted-constructs t)
  (modus-operandi-theme-bold-constructs t)
  (modus-operandi-theme-org-blocks 'greyscale)
  (modus-operandi-theme-variable-pitch-headings t)
  (modus-operandi-theme-3d-modeline nil))

(defadvice load-theme (before clear-previous-themes activate)
  "Clear existing theme settings instead of layering them"
  (mapc #'disable-theme custom-enabled-themes))
#+end_src

Though I rarely use them, I like these themes too. I find =modus-vivendi= too extreme for my tastes.

#+begin_src emacs-lisp
(use-package gruvbox-theme
  :defer t)
(use-package nord-theme
  :defer t)
(use-package tron-legacy-theme
  :defer t)
#+end_src

** Mode Line

#+begin_src emacs-lisp
(use-package minions
  :config (minions-mode t))

;; add columns to the mode-line
(column-number-mode t)
(setq display-time-format "%H:%M  %Y-%m-%d")
;;;; Covered by `display-time-format'
;; (setq display-time-24hr-format t)
;; (setq display-time-day-and-date t)
(setq display-time-interval 60)
(setq display-time-mail-directory nil)
(setq display-time-default-load-average nil)
(display-time-mode t)
#+end_src

* Org

** Keybindings
#+begin_src emacs-lisp
(use-package org
  :hook (org-mode . oht/org-mode-hook)
  :bind (:map org-mode-map
	      ("s-\\ ." . org-time-stamp)
	      ("s-\\ t" . org-todo)
	      ("s-\\ n" . org-narrow-to-subtree)
	      ("s-\\ w" . widen)
	      ("s-\\ s" . org-search-view)
	      ("s-\\ <" . org-insert-structure-template)
	      ("s-\\ l" . org-store-link)
	      ("s-\\ i" . org-insert-last-stored-link)
	      ("s-\\ m" . org-toggle-link-display)
	      ("s-\\ I" . org-clock-in)
	      ("s-\\ O" . org-clock-out)
	      ("s-\\ h" . hydra-org/body)
		))
#+end_src

** Settings

#+begin_src emacs-lisp
;; do not indent text below a headline
(setq org-adapt-indentation nil)

;; I don't like not seeing the stars, since those are markup
(setq org-hide-leading-stars nil)

;; This prevents editing inside folded sections
(setq org-catch-invisible-edits 'show-and-error)

(add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
(add-to-list 'org-structure-template-alist '("f" . "src fountain"))

;; this sets "refile targets" to any headline, level 1-3, in you agenda files.
(setq org-refile-targets
      '((org-agenda-files :maxlevel . 3)))
(setq org-refile-allow-creating-parent-nodes 'confirm)

;; Make C-a, C-e, and C-k smarter with regard to headline tags.
(setq org-special-ctrl-a/e t)
(setq org-special-ctrl-k t)
#+end_src

** Look & Feel

#+begin_src emacs-lisp
;; by default, hide org-markup
;; I have a toggle for this defined in functions
(setq org-hide-emphasis-markers t)

;; Style quote and verse blocks
(setq org-fontify-quote-and-verse-blocks t)

;; Character to display at the end of a folded headline
;;(setq org-ellipsis " â¬Ž")

;; this tells org to use the current window for agenda
;; rather than creating a split
(setq org-agenda-window-setup 'current-window)
#+end_src

** Source Code Blocks

#+begin_src emacs-lisp
(setq org-src-fontify-natively t)
(setq org-src-tab-acts-natively t)
(setq org-edit-src-content-indentation 0)
#+end_src

** Lists

#+begin_src emacs-lisp
;; Lists may be labelled with letters.
(setq org-list-allow-alphabetical t)

;; This sets the sequence of plain list bullets
;; The syntax is confusing and I don't understand it,
;; but I like the results.
(setq org-list-demote-modify-bullet '(("+" . "*") ("*" . "-") ("-" . "+")))

;; Increase sub-item indentation by this amount
;; the default is 2 so the below means 2+2 = 4 (spaces)
(setq org-list-indent-offset 2)
#+end_src

** Keywords

#+begin_src emacs-lisp
(setq org-todo-keywords
      '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
        (sequence "WAITING(w)" "HOLD(h)" "|" "CANCELLED(c)")))

;; Ensure that a task canâ€™t be marked as done if it contains
;; unfinished subtasks or checklist items. This is handy for
;; organizing "blocking" tasks hierarchically.
(setq org-enforce-todo-dependencies t)
(setq org-enforce-todo-checkbox-dependencies t)

;; This adds 'COMPLETED: DATE' when you move something to a DONE state
(setq org-log-done 'time)
#+end_src

** Tags

I find tags to be of very limited utility, but it is useful to tag truly unimportant things to that you can match filter them out of your agenda view. You can group those tags so that you only have to match against the group name.

#+begin_src emacs-lisp
(setq org-tag-alist '(("research" . ?r)
		      ("buy"      . ?b)
		      ("mac"      . ?m)
		      ("emacs"    . ?k)
		      ("org"      . ?o)
		      ("errand"   . ?e)
		      ))

;; Tags start immediately after the headline
;; I have this set because I'm typically in variable-pitch-mode
;; when editing org-files, in which the tag column doesn't align correctly
(setq org-tags-column 0)
#+end_src

** Capture Templates

#+begin_src emacs-lisp
(setq org-capture-templates
      '(("p" "Personal Inbox" entry
         (file+headline "~/Documents/org-files/refile.org" "Personal")
         "* %?\n\n")
        ("P" "Personal Log Entry" entry
         (file "~/Documents/org-files/logbook.org")
         "* %?\n%t\n\n")
        ("i" "Ingenuity Inbox" entry
         (file+headline "~/Documents/org-files/refile.org" "Ingenuity")
         "* %?\n\n")
        ("I" "Ingenuity Log Entry" entry
         (file "~/Documents/org-files/ingenuity_logbook.org")
         "* %^{Log type|Meeting: |Call: } %? %t\n\n")
        ))
#+end_src

** Agenda

This defines which files you want included in your agenda/TODO views.

#+begin_src emacs-lisp
(setq org-agenda-files
      '("~/Documents/org-files/"
	"~/Documents/writing/kindred/compendium.org"
	))
#+end_src

This defines custom agendas.

#+begin_src emacs-lisp
(setq org-agenda-custom-commands
      '(
        ("v" "Today + Tasks: not scheduled, not WAIT"
         ((agenda "d" ((org-agenda-span 'day)))
          (tags "/TODO"
                ((org-agenda-overriding-header "Available Tasks")
                 (org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled))
                 ))))
        ("i" "Important Tasks"
         ((tags "-emacs-/TODO"
                ((org-agenda-overriding-header "Important Tasks")
                (org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled)))
                )))
        ("c" "Complete - Agenda and ALL todos"
         ((agenda "")
          (todo "TODO|WAIT"
                ((org-agenda-overriding-header "Global list of TODO items of type: ALL (non-scheduled)")
                 (org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled))
                 ))
          ))
        ))
#+end_src

Each type of agenda view can be independently customized. The only thing I've changed from the default is that in the todo view I want things sorted first by category, then by priority within that. For more info see the documentation for the variable =org-agenda-sorting-strategy=.

#+begin_src emacs-lisp
;; (setq org-agenda-sorting-strategy
;;       '(
;; 	((agenda habit-down time-up priority-down category-up)
;; 	 (todo category-up priority-down)
;; 	 (tags priority-down category-keep)
;; 	 (search category-keep))))
#+end_src

And here we have some custom commands for the agenda view.

#+begin_src emacs-lisp
;; You have to wait until org-agenda loads because org itself
;; doesn't know what 'org-agenda-mode-map' is.
(eval-after-load "org-agenda"
'(progn
	(define-key org-agenda-mode-map
		"S" 'org-agenda-schedule)
		))
#+end_src

** Org hydra

#+begin_src emacs-lisp
(defhydra hydra-org (:color pink :hint nil)
  "
Org                    Links                 Outline
 _q_ quit              _i_ insert            _<_ previous
 _o_ edit              _n_ next              _>_ next
 ^^                    _p_ previous          _a_ all
 ^^                    _s_ store             _g_ go
 ^^                    ^^                    _v_ overview
"
  ("q" nil)
  ("<" org-backward-element)
  (">" org-forward-element)
  ("a" outline-show-all)
  ("g" counsel-org-goto :color blue)
  ("i" org-insert-link :color blue)
  ("n" org-next-link)
  ("o" org-edit-special :color blue)
  ("p" org-previous-link)
  ("s" org-store-link)
  ("v" org-overview))
#+end_src

** Org-Agenda Hydra

This is beautiful. It is taken from [[https://oremacs.com/2016/04/04/hydra-doc-syntax/][abo-abo]] (creator of hydra). It creates view toggles and displays the status of those toggles.

#+begin_src emacs-lisp
;; You have to wait until org-agenda loads because org itself
;; doesn't know what 'org-agenda-mode-map' is.
(eval-after-load "org-agenda"
'(progn
	(define-key org-agenda-mode-map
		"v" 'hydra-org-agenda-view/body)
		))

(defun org-agenda-cts ()
  (let ((args (get-text-property
               (min (1- (point-max)) (point))
               'org-last-args)))
    (nth 2 args)))
(defhydra hydra-org-agenda-view (:hint none)
  "
_d_: ?d? day        _g_: time grid=?g? _a_: arch-trees
_w_: ?w? week       _[_: inactive      _A_: arch-files
_t_: ?t? fortnight  _f_: follow=?f?    _r_: report=?r?
_m_: ?m? month      _e_: entry =?e?    _D_: diary=?D?
_y_: ?y? year       _q_: quit          _L__l__c_: ?l?"
  ("SPC" org-agenda-reset-view)
  ("d" org-agenda-day-view
   (if (eq 'day (org-agenda-cts))
       "[x]" "[ ]"))
  ("w" org-agenda-week-view
   (if (eq 'week (org-agenda-cts))
           "[x]" "[ ]"))
  ("t" org-agenda-fortnight-view
       (if (eq 'fortnight (org-agenda-cts))
           "[x]" "[ ]"))
  ("m" org-agenda-month-view
       (if (eq 'month (org-agenda-cts)) "[x]" "[ ]"))
  ("y" org-agenda-year-view
       (if (eq 'year (org-agenda-cts)) "[x]" "[ ]"))
  ("l" org-agenda-log-mode
       (format "% -3S" org-agenda-show-log))
  ("L" (org-agenda-log-mode '(4)))
  ("c" (org-agenda-log-mode 'clockcheck))
  ("f" org-agenda-follow-mode
       (format "% -3S" org-agenda-follow-mode))
  ("a" org-agenda-archives-mode)
  ("A" (org-agenda-archives-mode 'files))
  ("r" org-agenda-clockreport-mode
       (format "% -3S" org-agenda-clockreport-mode))
  ("e" org-agenda-entry-text-mode
       (format "% -3S" org-agenda-entry-text-mode))
  ("g" org-agenda-toggle-time-grid
       (format "% -3S" org-agenda-use-time-grid))
  ("D" org-agenda-toggle-diary
       (format "% -3S" org-agenda-include-diary))
  ("!" org-agenda-toggle-deadlines)
  ("["
   (let ((org-agenda-include-inactive-timestamps t))
     (org-agenda-check-type t 'timeline 'agenda)
     (org-agenda-redo)))
  ("q" (message "Abort") :exit t))
#+end_src

* Auto-complete

I've tried a few completion packages and they've all left me cold. =hippy-expand= generally gets me what I want, but I'd like the pop-up list to use =ivy/counsel=. Some googling led me to this.

#+begin_src emacs-lisp
;; https://gist.github.com/JohnLunzer/7c6d72a14c76c0a3057535e4f6148ef8
(defun my-hippie-expand-completions (&optional hippie-expand-function)
  "Return list of completions generated by `hippie-expand'."
  (save-excursion
    (let ((this-command 'my-hippie-expand-completions)
          (last-command last-command)
          (hippie-expand-function (or hippie-expand-function 'hippie-expand)))
      (while (progn
               (funcall hippie-expand-function nil)
               (setq last-command 'my-hippie-expand-completions)
               (not (equal he-num -1))))
      ;; Provide the options in the order in which they are normally generated.
      (delete he-search-string (reverse he-tried-table)))))

(defun my-ido-or-ivy-hippie-expand-with (hippie-expand-function)
  "Offer ido or ivy based completion using the specified hippie-expand function."
  (let* ((options (my-hippie-expand-completions hippie-expand-function)))
    (if options
        (progn
          (if (> (safe-length options) 1)
              (if (require 'ivy nil t)
                  (setq selection (ivy-read "Completions: " options))
                (setq selection (ido-completing-read "Completions: " options)))
            (setq selection (car options)))
          (if selection
              (he-substitute-string selection t)))
      (message "No expansion found"))))

(defun my-ido-or-ivy-hippie-expand ()
  "Offer ido or ivy based completion for the word at point."
  (interactive)
  (my-ido-or-ivy-hippie-expand-with 'hippie-expand))
#+end_src

* Secondary Selection

** Background

In the olden days, many computer programs (like the X-Windows system and WordStar) had something called =secondary-selection=. Robert Sawyer, [[https://arstechnica.com/information-technology/2017/03/wordstar-a-writers-word-processor/][writing in Ars Technica]], described the feature thus (WordStar called them "blocks"):

#+begin_quote
WordStar was rare among word processing programs in that it permitted the user to mark (highlight) a block of text (with ^KB and ^KK commands) and leave it marked in place, and then go to a different position in the document and later (even after considerable work on other things) copy the block (with ^KC) or move it to a new location (with ^KV). Many users found it much easier to manipulate blocks this way than with the Microsoft Word system of highlighting with a mouse and then being forced by Word's select-then-do approach to immediately deal with the marked block, lest any typing replace it.
#+end_quote

Emacs, in fact, supports this and calls it "secondary selection" but it is not exactly well documented, and the Emacs-literati haven't seemed to have written much about it. I did a deep dive and wrapped everything in my own functions and then in a hydra for easy access.

- =meta-left-click/drag= to mark a secondary selection.
- You can also use the hydra to make the current region the secondary selection.
- Once the secondary selection is active you can go about your typing, including copy/paste actions.
- Then, when you want to do something with the secondary selection, activate the hydra.
- Another scenario: when you realize, mid-typing, that you want to paste text from elsewhere, you can leave the insertion point where it is, make a secondary selection, and insert it directly.

** References

- The [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Secondary-Selection.html][official documentation]] is somewhat sparse, and assumes you'll only use the mouse for this.
- [[https://www.emacswiki.org/emacs/SecondarySelection][The Emacs Wiki has some info]], but seems a little out of date given that there are so many built-in functions for this now.
- Charles Lindsey made [[http://www.cs.man.ac.uk/~lindsec/secondary-selection.html][a video]] that nicely explains the basic idea behind secondary selection.

** Functions

All but one of these functions is built-in, but in their default form they're not =interactive= so any keybindings need to include =(lambda () (interactive) (function-name))= in order to work, and some of their documentation is a little sketchy, so I've wrapped them all in my own functions. Just makes things a little easier to work with.

#+begin_src emacs-lisp
(defun oht/cut-secondary-selection ()
  "Cut the secondary selection."
  (interactive)
  (mouse-kill-secondary))

(defun oht/copy-secondary-selection ()
  "Copy the secondary selection."
  (interactive)
  ;; there isn't a keybinding-addressable function to kill-ring-save
  ;; the 2nd selection so here I've made my own. This is extracted
  ;; directly from 'mouse.el:mouse-secondary-save-then-kill'
  (kill-new 
   (buffer-substring (overlay-start mouse-secondary-overlay)
		     (overlay-end mouse-secondary-overlay))
   t))

(defun oht/cut-secondary-selection-paste ()
  "Cut the secondary selection and paste at point."
  (interactive)
  (mouse-kill-secondary)
  (yank))

(defun oht/copy-secondary-selection-paste ()
  "Paste the secondary selection and paste at point."
  (interactive)
  (oht/copy-secondary-selection)
  (yank))
#+end_src

** Secondary Selection Hydra

#+begin_src emacs-lisp
(defhydra hydra-secondary-selection (:color blue)
  "Secondary Selection"
  ("xx" oht/cut-secondary-selection "Cut 2nd")
  ("cc" oht/copy-secondary-selection "Copy 2nd")
  ("xv" oht/cut-secondary-selection-paste "Cut 2nd & Paste")
  ("cv" oht/copy-secondary-selection-paste "Copy 2nd & Paste")
  ("m" (lambda () (interactive)(secondary-selection-from-region)) "Mark as 2nd")
  ("g" (lambda () (interactive)(secondary-selection-to-region)) "Goto 2nd")
  ("q" nil "cancel"))
#+end_src

* Modal Editing

I don't really want to use =evil-mode=. It does too much for my taste. I much prefer this simpler solution.

#+begin_src emacs-lisp
;; hydra-modal functions
(defun hydra-modal/pre ()
  "When activating the hydra-modal, change the cursor to a box"
  (set-default 'cursor-type 'box)
  (blink-cursor-mode -1))

(defun hydra-modal/post ()
  "When exiting the hydra-modal, change the cursor to a bar"
  (set-default 'cursor-type 'bar)
  (blink-cursor-mode 1))

(defhydra hydra-modal (:hint none :pre hydra-modal/pre :post hydra-modal/post :color pink)
  "/// MODAL HYDRA"
  ;; move one character
  ("h" backward-char "left")
  ("l" forward-char "right")
  ("j" next-line "next")
  ("k" previous-line "previous")
  ;; move larger
  ("C-h" backward-word "previous word")
  ("C-l" forward-word "end of next word")
  ("b" backward-word "previous word")
  ("w" oht/forward-word-beginning "beginning of next word")
  ("e" forward-word "end of next word")
  ("C-k" backward-paragraph "back paragraph")
  ("C-j" forward-paragraph "forward paragraph")
  ("u" beginning-of-visual-line "start of line")
  ("p" end-of-visual-line "end of line")
  ("0" beginning-of-visual-line "start of line")
  ("$" end-of-visual-line "end of line")
  ("/" ctrlf-forward-fuzzy "search forward")
  ("?" ctrlf-backward-fuzzy "search backward")
  ;; edit
  ("J" oht/join-line-next "join")
  ("y" kill-ring-save "Copy")
  ("P" yank "paste")
  ("<DEL>" kill-region "kill region")
  ("d" oht/kill-region-or-char "kill region")
  ("D" kill-line "Kill to EOL")
  ("c" oht/kill-region-or-char "change" :color blue)
  ("C" kill-line "change to EOL" :color blue)
  ("I" beginning-of-visual-line "append" :color blue)
  ("a" forward-char "append" :color blue)
  ("A" end-of-visual-line "append line" :color blue)
  ("o" oht/open-line-below "open below" :color blue)
  ("O" oht/open-line-above "open above" :color blue)
  ("!" hydra-manipulate/body "manipulate" :color blue)
  ;; view
  ("z" recenter-top-bottom "cycle recenter")
  ("[" scroll-down-line "scroll line up")
  ("]" scroll-up-line "scroll line down")
  ("{" scroll-down-command "scroll up")
  ("}" scroll-up-command "scroll down")
  ;; select
  ("v" set-mark-command "mark")
  ("V" oht/mark-whole-line "mark whole line")
  ("C-v" rectangle-mark-mode "rectangle mark")
  ("C-r" replace-rectangle "replace rectangle")
  ("x" exchange-point-and-mark "swap point/mark")
  ;; exit
  ("s-j" nil "cancel" :color blue)
  ("i" nil "cancel" :color blue))
#+end_src

* Window Management

** Hydra

Many of these commands are duplicated under [[*Windows Leader][Windows Leader]] below. Those are for one-off actions, this hydra is for entering a mini-mode where I want to do a series of window actions. The two compliment each other.

#+begin_src emacs-lisp
(defhydra hydra-windows (:color red)
  "Windows & Splits"
  ("<tab>" other-window "Cycle active window")
  ("v" oht/split-beside "Vertical Split")
  ("s" oht/split-below "Split, Horizonal")
  ("o" delete-other-windows "Only This Window" :color blue)
  ("k" delete-window "Delete Window")
  ("r" oht/toggle-window-split "Rotate Window Split")
  ("b" balance-windows "Balance")
  ("[" shrink-window "Smaller VERT")
  ("]" enlarge-window "Bigger VERT")
  ("{" shrink-window-horizontally "Smaler HORZ")
  ("}" enlarge-window-horizontally "Bigger HORZ")
  ("<up>" windmove-up "Move UP")
  ("<down>" windmove-down "Move DOWN")
  ("<left>" windmove-left "Move LEFT")
  ("<right>" windmove-right "Move RIGHT")
  ("q" nil "cancel" :color blue))
#+end_src

** Windows Leader

#+begin_src emacs-lisp
(bind-keys :prefix-map oht/windows-leader
	   :prefix "s-="
	   ("s" . oht/split-below)
	   ("v" . oht/split-beside)
	   ("h" . hydra-windows/body)
	   ("k" . delete-window)
	   ("o" . delete-other-windows)
	   ("b" . balance-windows)
	   ("r" . oht/toggle-window-split))
#+end_src

* Hydras

Hydras should be reserved for mini-modes, /ie/ places where you'll want to call several functions in a row. If all you're doing is grouping similar commands then which-key should suffice.

** Info: Hydra Colors

[[https://github.com/abo-abo/hydra/wiki/Hydra-Colors][Official Documentation]]

| Color    | Defined keys        | Other keys          |
|----------+---------------------+---------------------|
| red      | Accept and Continue | Accept and Exit     |
| pink     | Accept and Continue | Accept and Continue |
| amaranth | Accept and Continue | Reject and Continue |
| teal     | Exit                | Reject and Continue |
| blue     | Exit                | Accept and Exit     |

** Text Manipulation

These commands pretty much require a region.

#+begin_src emacs-lisp
(defhydra hydra-manipulate (:color teal)
  "Manipulate Text"
  ("|" oht/shell-command-on-region-replace "Pipe to shell")
  ("j" oht/join-line-next "Join line with next" :color red)
  ("J" unfill-region "Unfill region")
  ("d" downcase-region "Downcase")
  ("u" upcase-region "Upcase")
  ("c" capitalize-region "Capitalise")
  ("s" sort-lines "Sort")
  ("-" delete-duplicate-lines "Del Dupes")
  ("q" nil "cancel"))
#+end_src

** Transpose
There are so many ways to transpose in Emacs, why not get help?

#+begin_src emacs-lisp
(defhydra hydra-transpose (:color blue)
  "Transpose"
  ("c" transpose-chars "characters")
  ("w" transpose-words "words")
  ("o" org-transpose-words "Org mode words")
  ("l" transpose-lines "lines")
  ("s" transpose-sentences "sentences")
  ("e" org-transpose-elements "Org mode elements")
  ("p" transpose-paragraphs "paragraphs")
  ("t" org-table-transpose-table-at-point "Org mode table")
  ("x" transpose-sexps "s expressions")
  ("q" nil "cancel"))
#+end_src

** Dired

#+begin_src emacs-lisp
;; dired commands
(defhydra hydra-dired (:hint nil :color pink)
  "
_+_ mkdir          _v_iew           _m_ark             _(_ details        _i_nsert-subdir    wdired
_C_opy             _O_ view other   _U_nmark all       _)_ omit-mode      _$_ hide-subdir    C-x C-q : edit
_D_elete           _o_pen other     _u_nmark           _l_ redisplay      _w_ kill-subdir    C-c C-c : commit
_R_ename           _M_ chmod        _t_oggle           _g_ revert buf     _e_ ediff          C-c ESC : abort
_Y_ rel symlink    _G_ chgrp        _E_xtension mark   _s_ort             _=_ pdiff
_S_ymlink          ^ ^              _F_ind marked      _._ toggle hydra   \\ flyspell
_r_sync            ^ ^              ^ ^                ^ ^                _?_ summary
_z_ compress-file  _A_ find regexp
_Z_ compress       _Q_ repl regexp

T - tag prefix
"
  ("\\" dired-do-ispell)
  ("(" dired-hide-details-mode)
  (")" dired-omit-mode)
  ("+" dired-create-directory)
  ("=" diredp-ediff)         ;; smart diff
  ("?" dired-summary)
  ("$" diredp-hide-subdir-nomove)
  ("A" dired-do-find-regexp)
  ("C" dired-do-copy)        ;; Copy all marked files
  ("D" dired-do-delete)
  ("E" dired-mark-extension)
  ("e" dired-ediff-files)
  ("F" dired-do-find-marked-files)
  ("G" dired-do-chgrp)
  ("g" revert-buffer)        ;; read all directories again (refresh)
  ("i" dired-maybe-insert-subdir)
  ("l" dired-do-redisplay)   ;; relist the marked or singel directory
  ("M" dired-do-chmod)
  ("m" dired-mark)
  ("O" dired-display-file)
  ("o" dired-find-file-other-window)
  ("Q" dired-do-find-regexp-and-replace)
  ("R" dired-do-rename)
  ("r" dired-do-rsynch)
  ("S" dired-do-symlink)
  ("s" dired-sort-toggle-or-edit)
  ("t" dired-toggle-marks)
  ("U" dired-unmark-all-marks)
  ("u" dired-unmark)
  ("v" dired-view-file)      ;; q to exit, s to search, = gets line #
  ("w" dired-kill-subdir)
  ("Y" dired-do-relsymlink)
  ("z" diredp-compress-this-file)
  ("Z" dired-do-compress)
  ("q" nil)
  ("." nil :color blue))

(define-key dired-mode-map "." 'hydra-dired/body)
#+end_src

** Buffer Menu

#+begin_src emacs-lisp
(defhydra hydra-buffer-menu (:color pink
                                    :hint nil)
  "
^Mark^             ^Unmark^           ^Actions^          ^Search
^^^^^^^^-----------------------------------------------------------------
_m_: mark          _u_: unmark        _x_: execute       _R_: re-isearch
_s_: save          _U_: unmark up     _b_: bury          _I_: isearch
_d_: delete        ^ ^                _g_: refresh       _O_: multi-occur
_D_: delete up     ^ ^                _T_: files only: % -28`Buffer-menu-files-only
_~_: modified
"
  ("m" Buffer-menu-mark)
  ("u" Buffer-menu-unmark)
  ("U" Buffer-menu-backup-unmark)
  ("d" Buffer-menu-delete)
  ("D" Buffer-menu-delete-backwards)
  ("s" Buffer-menu-save)
  ("~" Buffer-menu-not-modified)
  ("x" Buffer-menu-execute)
  ("b" Buffer-menu-bury)
  ("g" revert-buffer)
  ("T" Buffer-menu-toggle-files-only)
  ("O" Buffer-menu-multi-occur :color blue)
  ("I" Buffer-menu-isearch-buffers :color blue)
  ("R" Buffer-menu-isearch-buffers-regexp :color blue)
  ("c" nil "cancel")
  ("v" Buffer-menu-select "select" :color blue)
  ("o" Buffer-menu-other-window "other-window" :color blue)
  ("q" quit-window "quit" :color blue))
(define-key Buffer-menu-mode-map "." 'hydra-buffer-menu/body)
#+end_src

* Keybindings

** Enhance Emacs

#+begin_src emacs-lisp
(bind-key "C-s" 'ctrlf-forward-fuzzy)
(bind-key "C-r" 'ctrlf-backward-fuzzy)
(bind-key "M-<up>" 'oht/move-line-up)
(bind-key "M-<down>" 'oht/move-line-down)
(bind-key "M-o" 'other-window)
(bind-key "M-z" 'zap-up-to-char) ;the default is 'zap-to-char
(bind-key "M-;" 'flyspell-correct-previous)
(bind-key "s-M-z" 'undo-tree-visualize)
(bind-key "M-s-s" 'save-some-buffers) ;save others

;; When region is active, make `capitalize-word' and friends act on
;; it.
(bind-key "M-c" #'capitalize-dwim)
(bind-key "M-l" #'downcase-dwim)
(bind-key "M-u" #'upcase-dwim)
#+end_src

This cycles the spacing around point between a single space, no spaces, or the original spacing:

#+begin_src emacs-lisp
(bind-key "M-SPC" 'cycle-spacing)
#+end_src

** Primary Bindings

#+begin_src emacs-lisp
(bind-key "s-p" 'execute-extended-command)
(bind-key "M-s-b" 'ibuffer)
;; vim has the wonderful . command, and emacs has repeat
;; s-y is my keybinding because excel has (a version of) repeat bound to that
(bind-key "s-y" 'repeat)
(bind-key "s-j" 'hydra-modal/body)
(bind-key "s-|" 'hydra-manipulate/body)
(bind-key "C-M-t" 'hydra-transpose/body)
(bind-key "C-S-<mouse-1>" 'mc/add-cursor-on-click)

(bind-key "s-1" 'org-agenda)
(bind-key "s-2" 'hydra-secondary-selection/body)
#+end_src

** Global Leader Bindings

#+begin_src emacs-lisp
(bind-keys :prefix-map oht/global-leader
	   :prefix "s-'"
	   ("c" . org-capture)
	   ("d" . sdcv-search)
	   ("h" . hl-line-mode)
	   ("l" . oht/toggle-line-numbers)
	   ("w" . oht/toggle-whitespace)
	   ("m" . magit-status)
	   ("<left>" . winner-undo)
	   ("<right>" . winner-redo)
	   ("k" . oht/kill-this-buffer)
	   )
#+end_src

# end of emacs-init.org
