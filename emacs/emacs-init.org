#+TITLE: Emacs Settings & Configuration
#+AUTHOR: Oliver Taylor

* Hello!

/Welcome!/ I'm sorry, but I'm not writing this for you, I'm writing this for me---well, /future/-me. I don't want to forget how this configuration file works, or why I did things this way, so I write it in [[https://en.wikipedia.org/wiki/Literate_programming][this format]] so I can read it later and understand what the hell /past/-me was thinking.

** What is This?

This document does 2 things simultaneously, it is both the configuration file containing all my settings and preferences that Emacs reads when it starts-up /and/ it is a document that's meant to be read by a human which explains what the configuration and settings do and why I want them done that way.

This file is called =emacs-init.org= and to make it work, you need the following in your =~/.emacs.d/init.el=:

#+begin_example
(require 'org)
(org-babel-load-file (expand-file-name "~/dot/emacs/emacs-init.org"))
#+end_example

** My Emacs Philosophy

1. Using Emacs makes no sense unless you customize it extensively. If you're not interested in, or don't want to bother with, customizing Emacs to the point where it molds around what you expect of it (rather than requiring /you to mold to it/) then save yourself the trouble and use another editor, there are a lot of great ones.

2. Accept that you will never remember Emacs keybindings, and that even if you do it will injure your pinky, and don't even bother trying. That's not a down-side, it means you don't have to learn anything new (!), just learn to make Emacs work the way you expect it to. That sounds like it might be difficult, but once you get the hang of customizing Emacs it becomes easy.

3. There's a few things you should learn to use in order to learn about Emacs's capabilities. Poke around =C-h ?= for Help. Use =counsel-M-x= to explore. Use =which-key= to give you hints for difficult to remember shortcuts.

4. Use =hydra= to set up what are basically "mini-modes". I don't know how I'd function without the one I have setup for window management. And the vim-ish hydra below is very useful indeed. As the saying goes "the best editor is not vim or emacs, but both".

** Inspiration and References

Anyone learning vim, emacs, zsh, bash, or something similar, spends a lot of time looking at other people's configuration files (much like this one). I've learned from some wonderful (and well documented) examples. Here is a list of the ones I've learned the most from:

- [[https://protesilaos.com/dotemacs/][Protesilaos Stavrou Dotemacs]]
- [[https://github.com/oantolin/emacs-config/blob/master/init.el][Oantolin emacs config]]
- [[https://blog.aaronbieber.com][Aaron Bieber, Blog & Dotfiles]]
- [[https://github.com/hrs/dotfiles/blob/main/emacs/dot-emacs.d/configuration.org][Harry R. Schwartz dotfiles]]
- [[https://yiufung.net/post/org-mode-hidden-gems-pt1/][Org-Mode Hidden Gems]]
- [[https://github.com/angrybacon/dotemacs/blob/master/dotemacs.org][Angry Bacon dotemacs]]
- [[https://gitlab.com/Kaligule/emacs-config/-/blob/master/config.org][Kaligule config.org]]

For more sources see [[https://pinboard.in/u:Oliver/t:emacs][my pinboard bookmarks]].

* Installation

First, make sure you're using the correct version. I like [[https://bitbucket.org/mituharu/emacs-mac/raw/892fa7b2501a403b4f0aea8152df9d60d63f391a/README-mac][Mitsuharu Yamamoto's Emacs fork]] because it provides [[https://bitbucket.org/mituharu/emacs-mac/src/f3402395995bf70e50d6e65f841e44d5f9b4603c/README-mac?at=master&fileviewer=file-view-default][a lot of nice stuff]] for people who want their Emacs to be a better macOS citizen.

* Settings

** Emacs Startup

I've seen it listed in a few places, so I'm trying it on, but this is supposed to help reduce emacs startup time.

#+begin_src emacs-lisp
(setq gc-cons-threshold 50000000)
#+end_src

This tells emacs to startup with a scratch buffer, with custom content, and to do it quietly.

#+begin_src emacs-lisp
(setq initial-scratch-message
      (concat
       ";; This buffer is for text that is not saved, and for Lisp evaluation.\n"
       ";; To create a file, visit it with C-x C-f and enter text in its buffer.\n"
       ";; WELCOME TO EMACS\n"))
(setq inhibit-splash-screen t
      inhibit-startup-message t
      inhibit-startup-echo-area-message t)
#+end_src

** Encoding

Set encoding to be UTF-8 everywhere.

#+begin_src emacs-lisp
(setq-default buffer-file-coding-system 'utf-8-unix)
(set-default-coding-systems 'utf-8-unix)
(setq locale-coding-system 'utf-8-unix)
(prefer-coding-system 'utf-8-unix)
#+end_src

** Customizing

When customizing Emacs interactively (ie: not in this document or =init.el=) Emacs appends code to your =init.el= file, which can be annoying when editing it by hand. This tells Emacs to place these customizations in a separate file.

#+begin_src emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(when (file-exists-p custom-file)
  (load custom-file :noerror))
#+end_src

** emacs.d layout

This tells emacs how I've laid-out by emacs directory.

#+begin_src emacs-lisp
(add-to-list 'custom-theme-load-path (expand-file-name "themes" user-emacs-directory))
(setq backup-directory-alist `(("." . "~/.emacs.d/saves")))
#+end_src

Emacs can automatically create backup files. This tells Emacs to put all backups in =~/.emacs.d/backups=. [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Backup-Files.html][More info]].

#+begin_src emacs-lisp
(setq backup-directory-alist `(("." . ,(concat user-emacs-directory
                                               "backups"))))
#+end_src

** Making Emacs More Consistent with macOS

The below is probably the biggest reason why I managed get over the intimidation of using Emacs in those first few days.

*** Modifiers

1. Makes the command keys act as =super=. =super= keybindings are basically not used by Emacs so they're a safe playground for assigning your own keybindings. I setup =s-q= for quit,  =s-s= for save, =s-z= for undo, =s-o= for open file, basically, all the standard Mac shortcuts. Once I did that Emacs became very usable immediately and that ease-of-use made learning Emacs a lot less painful.
2. Makes the right option key act as =meta= and the makes the left option key act as =alt=. This lets me use =meta= keybindings /and/ type characters that require =option/alt=. If you don't do that you can't insert characters like: £¢∞§¶•≠. Which is, I guess, only sometimes useful, but at least this way I /can/.

#+begin_src emacs-lisp
;; Command to super
(setq mac-command-modifier 'super)
(setq mac-right-command-modifier 'super)
;; Left-option to meta
(setq mac-option-modifier 'meta)
(setq mac-left-option-modifier 'meta)
;; Right-option to option
(setq mac-right-option-modifier 'meta)
(setq mac-right-option-modifier 'nil)
#+end_src

Due to historical reasons, emacs thinks =C-i= is the same as =TAB= and =C-m= is the same as =RETURN=. The below undoes that assumption.

#+begin_src emacs-lisp
(define-key input-decode-map [?\C-i] [C-i])
(bind-key "<C-i>" nil)
(define-key input-decode-map [?\C-m] [C-m])
#+end_src

*** Standard Mac Shortcuts

[[https://support.apple.com/en-us/HT201236]]

#+begin_src emacs-lisp
;; in emacs <del/backspace> is backward-delete and <delete> is forward-delete
;; and by default option+forward-delete has no mapping
(bind-key "M-<delete>" 'kill-word)
;; C-[ sends ESC so let's make ESC more predictable
(define-key key-translation-map (kbd "ESC") (kbd "C-g"))
(bind-key "s-," 'oht/find-settings)
(bind-key "s-n" 'make-frame-command)
(bind-key "s-s" 'save-buffer)         ;save
(bind-key "s-S" 'write-file)          ;save as
(bind-key "s-a" 'mark-whole-buffer)
(bind-key "s-o" 'counsel-find-file)
(bind-key "s-z" 'undo-tree-undo)
(bind-key "s-Z" 'undo-tree-redo)
(bind-key "s-x" 'kill-region)
(bind-key "s-c" 'kill-ring-save)
(bind-key "s-v" 'yank)
(bind-key "s-<backspace>" 'oht/kill-visual-line-backward)
(bind-key "s-w" 'oht/kill-this-buffer)
(bind-key "s-q" 'save-buffers-kill-terminal)
(bind-key "s-<up>" (kbd "M-<"))
(bind-key "s-<down>" (kbd "M->"))
(bind-key "s-l" 'oht/mark-whole-line)
(bind-key "s-M-l" 'mark-paragraph)
(bind-key "s-]" 'indent-rigidly-right-to-tab-stop)
(bind-key "s-[" 'indent-rigidly-left-to-tab-stop)
(bind-key "S-s-<left>" 'oht/expand-to-beginning-of-visual-line)
(bind-key "S-s-<right>" 'oht/expand-to-end-of-visual-line)
(bind-key "s-f" 'swiper)
(bind-key "s-<return>" 'oht/open-line-below)
(bind-key "S-s-<return>" 'oht/open-line-above)
;; Use same shortcuts as tab-movement for buffer movement
(bind-key "s-}" 'next-buffer)
(bind-key "s-{" 'previous-buffer)
; Mac follows the UNIX convention of C-h being the same as <DEL>
(bind-key "C-h" 'delete-backward-char)
;; Normally, C-? is used for undo/redo,
;; but I've rebound that elsewhere, so I can use it here
(bind-key* "C-?" 'help-command)
;; readline-style shortcuts, because I love them
(bind-key* "C-w" 'backward-kill-word)
(bind-key "C-u" 'oht/kill-line-backward)
;; No reason not to use command-u for this
(bind-key "s-u" 'universal-argument)
;; since ctrl+alt+b/f are system shortcuts for word movement, do that
(bind-key* "C-M-b" 'left-word)
(bind-key* "C-M-f" 'right-word)
;; respect alt+forward-delete
(bind-key* "M-<delete>" 'kill-word)
#+end_src

*** Replace Selection

By default, Emacs doesn't replace the selection (region) with anything you type, it just deletes your selection and appends what you type. The below makes what you type /replace/ your selection.

#+begin_src emacs-lisp
(delete-selection-mode t)
#+end_src

*** Visual Line Mode

Visual line mode is super helpful, but out-of-the-box it behaves inconsistently with the rest of macOS, so the below code brings it back in line.

#+begin_src emacs-lisp
;; Turn on word-wrap globally
(global-visual-line-mode t)
;; with visual-line-mode set,
;; C-a and C-b go to beginning/end-of-visual-line
;; which is inconsistant with standard Mac behaviour
(bind-key* "C-a" 'beginning-of-line)
(bind-key* "C-e" 'end-of-line)
(bind-key "s-<left>" 'beginning-of-visual-line)
(bind-key "s-<right>" 'end-of-visual-line)
;; C-k only killing the visual line also isn't how macOS works.
;; This has to be set to a custom function so minor modes can't hijack it.
(bind-key* "C-k" 'oht/kill-line)
#+end_src

** Uniquify!

When editing 2 files with the same name, like =~/foo/file= and =~/bar/file=, Emacs (amazingly) refers to those files as =file<~/foo>= and =file<~/bar>=. This makes Emacs refer to them as =foo/file= and =bar/file=, like a sane program.

#+begin_src emacs-lisp
;;(require 'uniquify)
(setq uniquify-buffer-name-style 'forward)
#+end_src

** Spelling

#+begin_src emacs-lisp
(setq ispell-program-name "/usr/local/bin/aspell")
(customize-set-variable 'ispell-extra-args '("--sug-mode=ultra"))
(setq ispell-list-command "list")
#+end_src

** General Settings

#+begin_src emacs-lisp
(global-auto-revert-mode t)           ; update buffer when file on disk changes
;;(desktop-save-mode 1)                 ; sessions
(save-place-mode 1)                   ; reopens the file to the same spot you left
(recentf-mode 1)                      ; enables "Open Recent..." in file menu
(setq tab-width 4)                    ; tabs=4 char
(setq help-window-select t)           ; focus new help windows when opened
(setq sentence-end-double-space nil)  ; ends sentence after 1 space
(fset 'yes-or-no-p 'y-or-n-p)         ; Changes all yes/no questions to y/n type
(setq create-lockfiles nil)           ; No need for ~ files when editing
#+end_src

* Packages

#+begin_src emacs-lisp
(use-package magit)
(use-package bind-key)
(use-package exec-path-from-shell)

(use-package orderless
  :ensure t
  :init ;(icomplete-mode 1)
  :custom (completion-styles '(orderless)))

(use-package counsel
  :ensure t
  :config (counsel-mode t)
  :custom
  (ivy-use-virtual-buffers t)
  (ivy-count-format "%d/%d ")
  (enable-recursive-minibuffers t)
  (ivy-count-format "(%d/%d) ")
  ;; by default ivy starts up with ^ in the input area this means you
  ;; have to know the first letter of what you're looking for. You can
  ;; set this to nil to change that.
  ;; (setq ivy-initial-inputs-alist nil)
)

(use-package ivy
  :config
  (setq ivy-re-builders-alist '((t . orderless-ivy-re-builder))))

(use-package ivy-rich
  :ensure t
  :config
  (ivy-rich-mode 1)
  (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line))

(use-package flyspell-correct
  :ensure t
  :custom
  (flyspell-correct-interface 'flyspell-correct-dummy)
)
(advice-add 'flyspell-correct-dummy :around
	    (defun my--fsc-wrapper (func &rest args)
	      (let ((selectrum-should-sort-p nil))
		(apply func args))))

(use-package multiple-cursors)
(use-package olivetti)
(use-package org
  :hook (org-mode . oht/org-mode-hook))
(use-package unfill)

(use-package fountain-mode)
(use-package lua-mode)
(use-package markdown-mode
  :hook oht/writing-mode
)

(use-package gruvbox-theme
  :defer t)
(use-package nord-theme
  :defer t)
(use-package tron-legacy-theme
  :defer t)

(use-package use-package-chords
  :ensure t
  :config
  (key-chord-mode 1)
  (key-chord-define-global ",." "<>\C-b"))

(use-package hydra
  :chords (("fj" . hydra-modal/body)))

(use-package which-key
  :config (which-key-mode t))

(use-package undo-tree
  :ensure t
  :config (global-undo-tree-mode 1)
  :custom
  (undo-tree-visualizer-timestamps t "Show timestamps in the undo-tree.")
  (undo-tree-visualizer-diff t "Show a diff of changes for the current node.")
  )

(use-package expand-region
  :bind
  ("s-e" . er/expand-region)
  ("s-E" . er/contract-region)
)

(use-package sdcv-mode
  :load-path "lisp/emacs-sdcv/")

#+end_src

** Mode Hooks

#+begin_src emacs-lisp
(defun oht/org-mode-hook ()
  (oht/writing-mode)
  (org-superstar-mode 1)
  (undo-tree-mode)
  )
(defun oht/emacs-lisp-mode ()
  (undo-tree-mode)
  (outline-minor-mode t)
  (rainbow-delimiters-mode t)
  )
(add-hook 'emacs-lisp-mode 'oht/emacs-lisp-mode)

(defun oht/fountain-mode-hook ()
  (fountain-add-continued-dialog nil)
  (fountain-highlight-elements (quote (section-heading)))
  )
(add-hook 'fountain-mode 'oht/fountain-mode-hook)

(add-hook 'dired-mode-hook
          (lambda ()
            (dired-hide-details-mode 1)
	    (auto-revert-mode)
	  ))
#+end_src

* Appearance

** Display

#+begin_src emacs-lisp
(menu-bar-mode 1)                          ; ensures full-screen avail on macOS
(tool-bar-mode -1)                         ; hide menu-bar
(scroll-bar-mode -1)                       ; hide scroll bars
(show-paren-mode t)                        ; highlight parens
(setq show-paren-delay 0)                  ; and show immediately
(setq visible-bell t)                      ; disable beep
(setq-default frame-title-format '("%b"))  ; show buffer name in titlebar
(set-default 'cursor-type 'bar)            ; use bar here, box in modes
(setq x-underline-at-descent-line t)       ; underline at descent, not baseline
#+end_src

** Fonts

Here the fonts are setup in a function so I can change them all in once step by calling =oht/set-font=.

#+begin_src emacs-lisp
(defun oht/set-font ()
  (interactive)
  "These settings are placed inside a function so that I can set them all at once by calling the function."
  (set-face-attribute 'default nil
		      :family "Iosevka Fixed SS08" :height 140 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
		      :family "Iosevka Fixed SS08" :height 140 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
		      :family "IBM Plex Serif" :height 150 :weight 'normal)
  (set-face-attribute 'bold nil :weight 'semibold)
  )

(oht/set-font)
#+end_src

** Theme

I use, and *love* /prot/'s [[https://gitlab.com/protesilaos/modus-themes][Modus Themes]].

#+begin_src emacs-lisp
(use-package modus-vivendi-theme
  :defer t
  :custom
  (modus-vivendi-theme-faint-syntax t)
  (modus-vivendi-theme-slanted-constructs t)
  (modus-vivendi-theme-bold-constructs t)
  (modus-vivendi-theme-3d-modeline t))

(use-package modus-operandi-theme
  :custom
  (modus-operandi-theme-faint-syntax t)
  (modus-operandi-theme-slanted-constructs t)
  (modus-operandi-theme-bold-constructs t)
  (modus-operandi-theme-org-blocks 'greyscale)
  (modus-operandi-theme-variable-pitch-headings t)
  (modus-operandi-theme-3d-modeline nil))

(defadvice load-theme (before clear-previous-themes activate)
  "Clear existing theme settings instead of layering them"
  (mapc #'disable-theme custom-enabled-themes))
#+end_src

** Mode Line

#+begin_src emacs-lisp
(use-package minions
  :config (minions-mode t))

;; add columns to the mode-line
(column-number-mode t)
(setq display-time-format "%H:%M  %Y-%m-%d")
;;;; Covered by `display-time-format'
;; (setq display-time-24hr-format t)
;; (setq display-time-day-and-date t)
(setq display-time-interval 60)
(setq display-time-mail-directory nil)
(setq display-time-default-load-average nil)
(display-time-mode t)
#+end_src

* Org

** Settings

#+begin_src emacs-lisp
;; do not indent text below a headline
(setq org-adapt-indentation nil)

;; I don't like not seeing the stars, since those are markup
(setq org-hide-leading-stars nil)

;; This prevents editing inside folded sections
(setq org-catch-invisible-edits 'show-and-error)

(add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
(add-to-list 'org-structure-template-alist '("f" . "src fountain"))

;; this sets "refile targets" to any headline, level 1-3, in you agenda files.
(setq org-refile-targets
      '((org-agenda-files :maxlevel . 3)))
(setq org-refile-allow-creating-parent-nodes 'confirm)
#+end_src

** Look & Feel

#+begin_src emacs-lisp
;; by default, hide org-markup
;; I have a toggle for this defined in functions
(setq org-hide-emphasis-markers t)

;; Style quote and verse blocks
(setq org-fontify-quote-and-verse-blocks t)

;; Character to display at the end of a folded headline
;;(setq org-ellipsis " ⬎")

;; this tells org to use the current window for agenda
;; rather than creating a split
(setq org-agenda-window-setup 'current-window)
#+end_src

I use =org-superstar= to replace headline and list-markup with more attractive options. An added benefit is that by transforming the markup into fancy bullets I get visual confirmation that the markup is going what I intend.

#+begin_src emacs-lisp
(use-package org-superstar
  :custom
  (org-superstar-headline-bullets-list '("❖ "))
  (org-superstar-special-todo-items nil)
  (org-superstar-item-bullet-alist
      '((?- . ?•)
	(?+ . ?▶)
	(?* . ?▷))))
#+end_src

** Source Code Blocks

#+begin_src emacs-lisp
(setq org-src-fontify-natively t)
(setq org-src-tab-acts-natively t)
(setq org-edit-src-content-indentation 0)
#+end_src

** Lists

#+begin_src emacs-lisp
;; Lists may be labelled with letters.
(setq org-list-allow-alphabetical t)

;; This sets the sequence of plain list bullets
;; The syntax is confusing and I don't understand it,
;; but I like the results.
(setq org-list-demote-modify-bullet '(("+" . "*") ("*" . "-") ("-" . "+")))

;; Increase sub-item indentation by this amount
;; the default is 2 so the below means 2+2 = 4 (spaces)
(setq org-list-indent-offset 2)
#+end_src

** Keywords

#+begin_src emacs-lisp
(setq org-todo-keywords
      '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
        (sequence "WAITING(w)" "HOLD(h)" "|" "CANCELLED(c)")))

;; Ensure that a task can’t be marked as done if it contains
;; unfinished subtasks or checklist items. This is handy for
;; organizing "blocking" tasks hierarchically.
(setq org-enforce-todo-dependencies t)
(setq org-enforce-todo-checkbox-dependencies t)

;; This adds 'COMPLETED: DATE' when you move something to a DONE state
(setq org-log-done 'time)
#+end_src

** Tags

I find tags to be of very limited utility, but it is useful to tag truly unimportant things to that you can match filter them out of your agenda view. You can group those tags so that you only have to match against the group name.

#+begin_src emacs-lisp
(setq org-tag-alist '(("research" . ?r)
		      ("buy"      . ?b)
		      ("mac"      . ?m)
		      ("emacs"    . ?k)
		      ("org"      . ?o)
		      ("errand"   . ?e)
		      ))

;; Tags start immediately after the headline
;; I have this set because I'm typically in variable-pitch-mode
;; when editing org-files, in which the tag column doesn't align correctly
(setq org-tags-column 0)
#+end_src

** Capture Templates

#+begin_src emacs-lisp
(setq org-capture-templates
      '(("p" "Personal Inbox" entry
         (file+headline "~/Documents/org-files/refile.org" "Personal")
         "* %?\n\n")
        ("P" "Personal Log Entry" entry
         (file "~/Documents/org-files/logbook.org")
         "* %?\n%t\n\n")
        ("i" "Ingenuity Inbox" entry
         (file+headline "~/Documents/org-files/refile.org" "Ingenuity")
         "* %?\n\n")
        ("I" "Ingenuity Log Entry" entry
         (file "~/Documents/org-files/ingenuity_logbook.org")
         "* %^{Log type|Meeting: |Call: } %? %t\n\n")
        ))
#+end_src

** Agenda

This defines which files you want included in your agenda/TODO views.

#+begin_src emacs-lisp
(setq org-agenda-files
      '("~/Documents/org-files/"
	"~/Documents/writing/kindred/compendium.org"
	))
#+end_src

This defines custom agendas.

#+begin_src emacs-lisp
(setq org-agenda-custom-commands
      '(
        ("v" "Today + Tasks: not scheduled, not WAIT"
         ((agenda "d" ((org-agenda-span 'day)))
          (tags "/TODO"
                ((org-agenda-overriding-header "Available Tasks")
                 (org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled))
                 ))))
        ("i" "Important Tasks"
         ((tags "-emacs-/TODO"
                ((org-agenda-overriding-header "Important Tasks")
                (org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled)))
                )))
        ("c" "Complete - Agenda and ALL todos"
         ((agenda "")
          (todo "TODO|WAIT"
                ((org-agenda-overriding-header "Global list of TODO items of type: ALL (non-scheduled)")
                 (org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled))
                 ))
          ))
        ))
#+end_src

Each type of agenda view can be independently customized. The only thing I've changed from the default is that in the todo view I want things sorted first by category, then by priority within that. For more info see the documentation for the variable =org-agenda-sorting-strategy=.

#+begin_src emacs-lisp
(setq org-agenda-sorting-strategy
      '(
	((agenda habit-down time-up priority-down category-up)
	 (todo category-up priority-down)
	 (tags priority-down category-keep)
	 (search category-keep))))
#+end_src

And here we have some custom commands for the agenda view.

#+begin_src emacs-lisp
;; You have to wait until org-agenda loads because org itself
;; doesn't know what 'org-agenda-mode-map' is.
(eval-after-load "org-agenda"
'(progn
	(define-key org-agenda-mode-map
		"S" 'org-agenda-schedule)
		))
#+end_src

* Auto-complete

I've tried a few completion packages and they've all left me cold. =hippy-expand= generally gets me what I want, but I'd like the pop-up list to use =ivy/counsel=. Some googling led me to this.

#+begin_src emacs-lisp
;; https://gist.github.com/JohnLunzer/7c6d72a14c76c0a3057535e4f6148ef8
(defun my-hippie-expand-completions (&optional hippie-expand-function)
  "Return list of completions generated by `hippie-expand'."
  (save-excursion
    (let ((this-command 'my-hippie-expand-completions)
          (last-command last-command)
          (hippie-expand-function (or hippie-expand-function 'hippie-expand)))
      (while (progn
               (funcall hippie-expand-function nil)
               (setq last-command 'my-hippie-expand-completions)
               (not (equal he-num -1))))
      ;; Provide the options in the order in which they are normally generated.
      (delete he-search-string (reverse he-tried-table)))))

(defun my-ido-or-ivy-hippie-expand-with (hippie-expand-function)
  "Offer ido or ivy based completion using the specified hippie-expand function."
  (let* ((options (my-hippie-expand-completions hippie-expand-function)))
    (if options
        (progn
          (if (> (safe-length options) 1)
              (if (require 'ivy nil t)
                  (setq selection (ivy-read "Completions: " options))
                (setq selection (ido-completing-read "Completions: " options)))
            (setq selection (car options)))
          (if selection
              (he-substitute-string selection t)))
      (message "No expansion found"))))

(defun my-ido-or-ivy-hippie-expand ()
  "Offer ido or ivy based completion for the word at point."
  (interactive)
  (my-ido-or-ivy-hippie-expand-with 'hippie-expand))
#+end_src

* Secondary Selection

** Background

In the olden days, many computer programs (like the X-Windows system and WordStar) had something called =secondary-selection=. Robert Sawyer, [[https://arstechnica.com/information-technology/2017/03/wordstar-a-writers-word-processor/][writing in Ars Technica]], described the feature thus (WordStar called them "blocks"):

#+begin_quote
WordStar was rare among word processing programs in that it permitted the user to mark (highlight) a block of text (with ^KB and ^KK commands) and leave it marked in place, and then go to a different position in the document and later (even after considerable work on other things) copy the block (with ^KC) or move it to a new location (with ^KV). Many users found it much easier to manipulate blocks this way than with the Microsoft Word system of highlighting with a mouse and then being forced by Word's select-then-do approach to immediately deal with the marked block, lest any typing replace it.
#+end_quote

Emacs, in fact, supports this and calls it "secondary selection" but it is not exactly well documented, and the Emacs-literati haven't seemed to have written much about it. I did a deep dive and wrapped everything in my own functions and then in a hydra for easy access.

- =meta-left-click/drag= to mark a secondary selection.
- You can also use the hydra to make the current region the secondary selection.
- Once the secondary selection is active you can go about your typing, including copy/paste actions.
- Then, when you want to do something with the secondary selection, activate the hydra.
- Another scenario: when you realize, mid-typing, that you want to paste text from elsewhere, you can leave the insertion point where it is, make a secondary selection, and insert it directly.

** References

- The [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Secondary-Selection.html][official documentation]] is somewhat sparse, and assumes you'll only use the mouse for this.
- [[https://www.emacswiki.org/emacs/SecondarySelection][The Emacs Wiki has some info]], but seems a little out of date given that there are so many built-in functions for this now.
- Charles Lindsey made [[http://www.cs.man.ac.uk/~lindsec/secondary-selection.html][a video]] that nicely explains the basic idea behind secondary selection.

** Functions

All but one of these functions is built-in, but in their default form they're not =interactive= so any keybindings need to include =(lambda () (interactive) (function-name))= in order to work, and some of their documentation is a little sketchy, so I've wrapped them all in my own functions. Just makes things a little easier to work with.

#+begin_src emacs-lisp
(defun oht/cut-secondary-selection ()
  "Cut the secondary selection."
  (interactive)
  (mouse-kill-secondary))

(defun oht/copy-secondary-selection ()
  "Copy the secondary selection."
  (interactive)
  ;; there isn't a keybinding-addressable function to kill-ring-save
  ;; the 2nd selection so here I've made my own. This is extracted
  ;; directly from 'mouse.el:mouse-secondary-save-then-kill'
  (kill-new 
   (buffer-substring (overlay-start mouse-secondary-overlay)
		     (overlay-end mouse-secondary-overlay))
   t))

(defun oht/cut-secondary-selection-paste ()
  "Cut the secondary selection and paste at point."
  (interactive)
  (mouse-kill-secondary)
  (yank))

(defun oht/copy-secondary-selection-paste ()
  "Paste the secondary selection and paste at point."
  (interactive)
  (oht/copy-secondary-selection)
  (yank))
#+end_src

** Secondary Selection Hydra

#+begin_src emacs-lisp
(defhydra hydra-secondary-selection (:color blue)
  "Secondary Selection"
  ("xx" oht/cut-secondary-selection "Cut 2nd")
  ("cc" oht/copy-secondary-selection "Copy 2nd")
  ("xv" oht/cut-secondary-selection-paste "Cut 2nd & Paste")
  ("cv" oht/copy-secondary-selection-paste "Copy 2nd & Paste")
  ("m" (lambda () (interactive)(secondary-selection-from-region)) "Mark as 2nd")
  ("g" (lambda () (interactive)(secondary-selection-to-region)) "Goto 2nd")
  ("q" nil "cancel"))
#+end_src

* Functions

#+begin_src emacs-lisp
(defun oht/writing-mode ()
  "Enable variable-pitch, flyspell, and increased line-spacing and margins."
  (interactive)
  (variable-pitch-mode t)
  (flyspell-mode t)
  (setq-local line-spacing 0.15)
  ;; define width of buffer margins
  (setq-local left-margin-width 1)
  (setq-local right-margin-width 1)
  ;;(set-window-buffer nil (current-buffer)) ; Use them now.
  )

(defun oht/fix-variable-org-indent ()
  "Fix for org-indent not hiding markup in org-indent-mode.
from: https://maxjmartin.com/Emacs%20Dotfile.html"
  (interactive)
  (set-face-attribute 'org-indent nil :inherit '(org-hide fixed-pitch))
  )

(defun oht/find-settings ()
  "Quickly open emacs-init.org"
  (interactive)
  (find-file "~/dot/emacs/emacs-init.org"))

(defun oht/counsel-find-org ()
  "Quickly open ~/Documents/org-files/"
  (interactive)
  (counsel-find-file "~/Documents/org-files/"))

(defun oht/kill-this-buffer ()
  "Quickly kill current buffer"
  (interactive)
  (kill-buffer (current-buffer)))

(defun oht/find-scratch ()
  (interactive)
  (if (string= (buffer-name) "*scratch*")
      (previous-buffer)
    (switch-to-buffer "*scratch*")))

;; Move Lines
(defmacro save-column (&rest body)
  `(let ((column (current-column)))
     (unwind-protect
         (progn ,@body)
       (move-to-column column))))
(put 'save-column 'lisp-indent-function 0)
(defun move-line-up ()
  "Move the current line up by 1 line"
  (interactive)
  (save-column
    (transpose-lines 1)
    (forward-line -2)))
(defun move-line-down ()
  "More the current line down by 1 line"
  (interactive)
  (save-column
    (forward-line 1)
    (transpose-lines 1)
    (forward-line -1)))

(defun oht/mark-whole-line ()
  "Mark the entirety of the current line."
  (interactive)
  (beginning-of-line)
  (set-mark-command nil)
  (end-of-line))

(defun oht/toggle-window-split ()
  "Toggle between vertical and horizontal split."
  ;; Source: https://www.emacswiki.org/emacs/ToggleWindowSplit.
  ;; Author: Jeff Dwork
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                         (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                         (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))

(defun oht/open-in-bbedit ()
  "Open current file or dir in BBEdit.
Adapted from:
URL `http://ergoemacs.org/emacs/emacs_dired_open_file_in_ext_apps.html'"
  (interactive)
  (let (($path (if (buffer-file-name) (buffer-file-name) (expand-file-name default-directory ) )))
    (message "path is %s" $path)
    (string-equal system-type "darwin")
    (shell-command (format "open -a BBEdit \"%s\"" $path))))

(defun oht/expand-to-beginning-of-visual-line ()
  "Set mark and move to beginning of visual line"
  (interactive)
  (set-mark-command nil)
  (beginning-of-visual-line)
  )
(defun oht/expand-to-end-of-visual-line ()
  "Set mark and move to end of visual line"
  (interactive)
  (set-mark-command nil)
  (end-of-visual-line)
  )

(defun oht/kill-line ()
  "Kill to end of line. This custom function is needed because binding c-k to kill-line doesn't work due to kill-line being remapped, so the remapped value is always executed. But calling a custom function obviates this and allows kill-line to be called directly. Nil is required."
  (interactive)
  (kill-line nil)
  )

(defun oht/kill-line-backward ()
  "Kill from the point to beginning of whole line"
  (interactive)
  (kill-line 0))

(defun oht/kill-visual-line-backward ()
  "Kill from the point to beginning of visual line"
  (interactive)
  (set-mark-command nil)
  (beginning-of-visual-line)
  (kill-region (region-beginning) (region-end))
  )

(defun oht/kill-region-or-char ()
  "If there's a region, kill it, if not, kill the next character."
  (interactive)
  (if (use-region-p)
      (kill-region (region-beginning) (region-end))
    (delete-forward-char 1 nil)))

(defun oht/toggle-line-numbers ()
  "Toggles display of line numbers. Applies to all buffers."
  (interactive)
  (if (bound-and-true-p display-line-numbers-mode)
      (global-display-line-numbers-mode -1)
    (global-display-line-numbers-mode)))

(defun oht/toggle-whitespace ()
  "Toggles display of indentation and space characters."
  (interactive)
  (if (bound-and-true-p whitespace-mode)
      (whitespace-mode -1)
    (whitespace-mode)))

(defun oht/open-line-below (arg)
  "Open a new indented line below the current one."
  (interactive "p")
  (end-of-line)
  (open-line arg)
  (next-line 1)
  (indent-according-to-mode))

(defun oht/open-line-above (arg)
  "Open a new indented line above the current one."
  (interactive "p")
  (beginning-of-line)
  (open-line arg)
  (indent-according-to-mode))

(defun oht/join-line-next ()
  (interactive)
  (join-line -1))

(defun oht/org-hide-emphasis-markers ()
  "Toggle whether or not the emphasis markers ~, =, *, _ are displayed"
  (interactive)
  (if (bound-and-true-p org-hide-emphasis-markers)
      (setq-local org-hide-emphasis-markers nil)
    (setq-local org-hide-emphasis-markers t))
  (font-lock-fontify-buffer)
  )

(defun oht/shell-command-on-region-replace (start end command)
  "Run shell-command-on-region interactivly replacing the region in place"
  (interactive (let (string)
                 (unless (mark)
                   (error "The mark is not set now, so there is no region"))
                 (setq string (read-from-minibuffer "Shell command on region: "
                                                    nil nil nil
                                                    'shell-command-history))
                 (list (region-beginning) (region-end)
                       string)))
  (shell-command-on-region start end command t t))

(defun oht/split-below ()
"Split horizontally and switch to that new window."
  (interactive)
  (split-window-below)
  (windmove-down))

(defun oht/split-beside ()
"Split vertically and switch to that new window."
  (interactive)
  (split-window-right)
  (windmove-right))

(defun oht/forward-word-beginning ()
  "Go to the end of the next word."
  (interactive)
  (forward-word 2)
  (backward-word))

#+end_src

* Modal Editing

I don't really want to use =evil-mode=. It does too much for my taste. I much prefer this simpler solution.

#+begin_src emacs-lisp
;; hydra-modal functions
(defun hydra-modal/pre ()
  "When activating the hydra-modal, change the cursor to a box"
  (set-default 'cursor-type 'box)
  (blink-cursor-mode -1))

(defun hydra-modal/post ()
  "When exiting the hydra-modal, change the cursor to a bar"
  (set-default 'cursor-type 'bar)
  (blink-cursor-mode 1))

(defhydra hydra-modal (:hint none :pre hydra-modal/pre :post hydra-modal/post :color pink)
  "/// MODAL HYDRA"
  ;; move one character
  ("h" backward-char "left")
  ("l" forward-char "right")
  ("j" next-line "next")
  ("k" previous-line "previous")
  ;; move larger
  ("C-h" backward-word "previous word")
  ("C-l" forward-word "end of next word")
  ("b" backward-word "previous word")
  ("w" oht/forward-word-beginning "beginning of next word")
  ("e" forward-word "end of next word")
  ("C-k" backward-paragraph "back paragraph")
  ("C-j" forward-paragraph "forward paragraph")
  ("u" beginning-of-visual-line "start of line")
  ("p" end-of-visual-line "end of line")
  ("0" beginning-of-visual-line "start of line")
  ("$" end-of-visual-line "end of line")
  ("/" swiper-isearch "search forward")
  ("?" swiper-isearch-backward "search backward")
  ;; edit
  ("J" oht/join-line-next "join")
  ("y" kill-ring-save "Copy")
  ("P" yank "paste")
  ("<DEL>" kill-region "kill region")
  ("d" oht/kill-region-or-char "kill region")
  ("D" kill-line "Kill to EOL")
  ("c" oht/kill-region-or-char "change" :color blue)
  ("C" kill-line "change to EOL" :color blue)
  ("I" beginning-of-visual-line "append" :color blue)
  ("a" forward-char "append" :color blue)
  ("A" end-of-visual-line "append line" :color blue)
  ("o" oht/open-line-below "open below" :color blue)
  ("O" oht/open-line-above "open above" :color blue)
  ("!" hydra-manipulate/body "manipulate" :color blue)
  ;; view
  ("z" recenter-top-bottom "cycle recenter")
  ("[" scroll-down-line "scroll line up")
  ("]" scroll-up-line "scroll line down")
  ("{" scroll-down-command "scroll up")
  ("}" scroll-up-command "scroll down")
  ;; select
  ("v" set-mark-command "mark")
  ("V" oht/mark-whole-line "mark whole line")
  ("C-v" rectangle-mark-mode "rectangle mark")
  ("C-r" replace-rectangle "replace rectangle")
  ("x" exchange-point-and-mark "swap point/mark")
  ;; exit
  ("s-j" nil "cancel" :color blue)
  ("i" nil "cancel" :color blue))
#+end_src

* Hydra

Hydras should be reserved for mini-modes, /ie/ places where you'll want to call several functions in a row. If all you're doing is grouping similar commands then which-key should suffice.

** Info: Hydra Colors

[[https://github.com/abo-abo/hydra/wiki/Hydra-Colors][Official Documentation]]

| Color    | Defined keys        | Other keys          |
|----------+---------------------+---------------------|
| red      | Accept and Continue | Accept and Exit     |
| pink     | Accept and Continue | Accept and Continue |
| amaranth | Accept and Continue | Reject and Continue |
| teal     | Exit                | Reject and Continue |
| blue     | Exit                | Accept and Exit     |

** Text Manipulation

These commands pretty much require a region.

#+begin_src emacs-lisp
(defhydra hydra-manipulate (:color teal)
  "Manipulate Text"
  ("|" oht/shell-command-on-region-replace "Pipe to shell")
  ("j" oht/join-line-next "Join line with next" :color red)
  ("J" unfill-region "Unfill region")
  ("d" downcase-region "Downcase")
  ("u" upcase-region "Upcase")
  ("c" capitalize-region "Capitalise")
  ("s" sort-lines "Sort")
  ("-" delete-duplicate-lines "Del Dupes")
  ("q" nil "cancel"))
#+end_src

** Transpose
There are so many ways to transpose in Emacs, why not get help?

#+begin_src emacs-lisp
(defhydra hydra-transpose (:color blue)
  "Transpose"
  ("c" transpose-chars "characters")
  ("w" transpose-words "words")
  ("o" org-transpose-words "Org mode words")
  ("l" transpose-lines "lines")
  ("s" transpose-sentences "sentences")
  ("e" org-transpose-elements "Org mode elements")
  ("p" transpose-paragraphs "paragraphs")
  ("t" org-table-transpose-table-at-point "Org mode table")
  ("x" transpose-sexps "s expressions")
  ("q" nil "cancel"))
#+end_src

** Dired

#+begin_src emacs-lisp
;; dired commands
(defhydra hydra-dired (:hint nil :color pink)
  "
_+_ mkdir          _v_iew           _m_ark             _(_ details        _i_nsert-subdir    wdired
_C_opy             _O_ view other   _U_nmark all       _)_ omit-mode      _$_ hide-subdir    C-x C-q : edit
_D_elete           _o_pen other     _u_nmark           _l_ redisplay      _w_ kill-subdir    C-c C-c : commit
_R_ename           _M_ chmod        _t_oggle           _g_ revert buf     _e_ ediff          C-c ESC : abort
_Y_ rel symlink    _G_ chgrp        _E_xtension mark   _s_ort             _=_ pdiff
_S_ymlink          ^ ^              _F_ind marked      _._ toggle hydra   \\ flyspell
_r_sync            ^ ^              ^ ^                ^ ^                _?_ summary
_z_ compress-file  _A_ find regexp
_Z_ compress       _Q_ repl regexp

T - tag prefix
"
  ("\\" dired-do-ispell)
  ("(" dired-hide-details-mode)
  (")" dired-omit-mode)
  ("+" dired-create-directory)
  ("=" diredp-ediff)         ;; smart diff
  ("?" dired-summary)
  ("$" diredp-hide-subdir-nomove)
  ("A" dired-do-find-regexp)
  ("C" dired-do-copy)        ;; Copy all marked files
  ("D" dired-do-delete)
  ("E" dired-mark-extension)
  ("e" dired-ediff-files)
  ("F" dired-do-find-marked-files)
  ("G" dired-do-chgrp)
  ("g" revert-buffer)        ;; read all directories again (refresh)
  ("i" dired-maybe-insert-subdir)
  ("l" dired-do-redisplay)   ;; relist the marked or singel directory
  ("M" dired-do-chmod)
  ("m" dired-mark)
  ("O" dired-display-file)
  ("o" dired-find-file-other-window)
  ("Q" dired-do-find-regexp-and-replace)
  ("R" dired-do-rename)
  ("r" dired-do-rsynch)
  ("S" dired-do-symlink)
  ("s" dired-sort-toggle-or-edit)
  ("t" dired-toggle-marks)
  ("U" dired-unmark-all-marks)
  ("u" dired-unmark)
  ("v" dired-view-file)      ;; q to exit, s to search, = gets line #
  ("w" dired-kill-subdir)
  ("Y" dired-do-relsymlink)
  ("z" diredp-compress-this-file)
  ("Z" dired-do-compress)
  ("q" nil)
  ("." nil :color blue))

(define-key dired-mode-map "." 'hydra-dired/body)
#+end_src

** Buffer Menu

#+begin_src emacs-lisp
;; Buffer-menu
(defhydra hydra-buffer-menu (:color pink
                                    :hint nil)
  "
^Mark^             ^Unmark^           ^Actions^          ^Search
^^^^^^^^-----------------------------------------------------------------
_m_: mark          _u_: unmark        _x_: execute       _R_: re-isearch
_s_: save          _U_: unmark up     _b_: bury          _I_: isearch
_d_: delete        ^ ^                _g_: refresh       _O_: multi-occur
_D_: delete up     ^ ^                _T_: files only: % -28`Buffer-menu-files-only
_~_: modified
"
  ("m" Buffer-menu-mark)
  ("u" Buffer-menu-unmark)
  ("U" Buffer-menu-backup-unmark)
  ("d" Buffer-menu-delete)
  ("D" Buffer-menu-delete-backwards)
  ("s" Buffer-menu-save)
  ("~" Buffer-menu-not-modified)
  ("x" Buffer-menu-execute)
  ("b" Buffer-menu-bury)
  ("g" revert-buffer)
  ("T" Buffer-menu-toggle-files-only)
  ("O" Buffer-menu-multi-occur :color blue)
  ("I" Buffer-menu-isearch-buffers :color blue)
  ("R" Buffer-menu-isearch-buffers-regexp :color blue)
  ("c" nil "cancel")
  ("v" Buffer-menu-select "select" :color blue)
  ("o" Buffer-menu-other-window "other-window" :color blue)
  ("q" quit-window "quit" :color blue))
#+end_src

** Window Management

Many of these commands are duplicated under [[*Windows Leader][Windows Leader]] below. Those are for one-off actions, this hydra is for entering a mini-mode where I want to do a series of window actions. The two compliment each other.

#+begin_src emacs-lisp
(defhydra hydra-windows (:color red)
  "Windows & Splits"
  ("<tab>" other-window "Cycle active window")
  ("v" oht/split-beside "Vertical Split")
  ("s" oht/split-below "Split, Horizonal")
  ("o" delete-other-windows "Only This Window" :color blue)
  ("k" delete-window "Delete Window")
  ("r" oht/toggle-window-split "Rotate Window Split")
  ("b" balance-windows "Balance")
  ("[" shrink-window "Smaller VERT")
  ("]" enlarge-window "Bigger VERT")
  ("{" shrink-window-horizontally "Smaler HORZ")
  ("}" enlarge-window-horizontally "Bigger HORZ")
  ("<up>" windmove-up "Move UP")
  ("<down>" windmove-down "Move DOWN")
  ("<left>" windmove-left "Move LEFT")
  ("<right>" windmove-right "Move RIGHT")
  ("q" nil "cancel" :color blue))
#+end_src

** Spelling

#+begin_src emacs-lisp
(defun hydra-flyspell/pre ()
  ;;(flyspell-mode t)
  )

(defhydra hydra-flyspell (:pre hydra-flyspell/pre :color red)
  "Spelling"
  (";" flyspell-goto-next-error "Next")
  (":" flyspell-correct-at-point "Correct")
  ("q" nil "cancel" :color blue))
#+end_src

** Org

#+begin_src emacs-lisp
(defhydra hydra-org (:color pink :hint nil)
  "
Org                    Links                 Outline
 _q_ quit              _i_ insert            _<_ previous
 _o_ edit              _n_ next              _>_ next
 ^^                    _p_ previous          _a_ all
 ^^                    _s_ store             _g_ go
 ^^                    ^^                    _v_ overview
"
  ("q" nil)
  ("<" org-backward-element)
  (">" org-forward-element)
  ("a" outline-show-all)
  ("g" counsel-org-goto :color blue)
  ("i" org-insert-link :color blue)
  ("n" org-next-link)
  ("o" org-edit-special :color blue)
  ("p" org-previous-link)
  ("s" org-store-link)
  ("v" org-overview))
#+end_src

** Org-Agenda View Toggle

This is beautiful. It is taken from [[https://oremacs.com/2016/04/04/hydra-doc-syntax/][abo-abo]] (creator of hydra). It creates view toggles and displays the status of those toggles.

#+begin_src emacs-lisp
;; You have to wait until org-agenda loads because org itself
;; doesn't know what 'org-agenda-mode-map' is.
(eval-after-load "org-agenda"
'(progn
	(define-key org-agenda-mode-map
		"v" 'hydra-org-agenda-view/body)
		))

(defun org-agenda-cts ()
  (let ((args (get-text-property
               (min (1- (point-max)) (point))
               'org-last-args)))
    (nth 2 args)))
(defhydra hydra-org-agenda-view (:hint none)
  "
_d_: ?d? day        _g_: time grid=?g? _a_: arch-trees
_w_: ?w? week       _[_: inactive      _A_: arch-files
_t_: ?t? fortnight  _f_: follow=?f?    _r_: report=?r?
_m_: ?m? month      _e_: entry =?e?    _D_: diary=?D?
_y_: ?y? year       _q_: quit          _L__l__c_: ?l?"
  ("SPC" org-agenda-reset-view)
  ("d" org-agenda-day-view
   (if (eq 'day (org-agenda-cts))
       "[x]" "[ ]"))
  ("w" org-agenda-week-view
   (if (eq 'week (org-agenda-cts))
           "[x]" "[ ]"))
  ("t" org-agenda-fortnight-view
       (if (eq 'fortnight (org-agenda-cts))
           "[x]" "[ ]"))
  ("m" org-agenda-month-view
       (if (eq 'month (org-agenda-cts)) "[x]" "[ ]"))
  ("y" org-agenda-year-view
       (if (eq 'year (org-agenda-cts)) "[x]" "[ ]"))
  ("l" org-agenda-log-mode
       (format "% -3S" org-agenda-show-log))
  ("L" (org-agenda-log-mode '(4)))
  ("c" (org-agenda-log-mode 'clockcheck))
  ("f" org-agenda-follow-mode
       (format "% -3S" org-agenda-follow-mode))
  ("a" org-agenda-archives-mode)
  ("A" (org-agenda-archives-mode 'files))
  ("r" org-agenda-clockreport-mode
       (format "% -3S" org-agenda-clockreport-mode))
  ("e" org-agenda-entry-text-mode
       (format "% -3S" org-agenda-entry-text-mode))
  ("g" org-agenda-toggle-time-grid
       (format "% -3S" org-agenda-use-time-grid))
  ("D" org-agenda-toggle-diary
       (format "% -3S" org-agenda-include-diary))
  ("!" org-agenda-toggle-deadlines)
  ("["
   (let ((org-agenda-include-inactive-timestamps t))
     (org-agenda-check-type t 'timeline 'agenda)
     (org-agenda-redo)))
  ("q" (message "Abort") :exit t))
#+end_src

* Keybindings

You can use =M-x describe-personal-keybindings= for a cheat-sheet.

** Keybindings Philosophy

1. Standard mac shortcuts should be supported wherever possible. And since mac inherits a lot of emacs keybindings anyway (and I use them outside emacs) I can leverage a lot of muscle memory. Additionally, I've largely internalized the =readline= keybindings (since I worked in =vim= for a long time) and so =^w=, =^u=, and =^h= are second-nature.

2. Enhance Emacs built-in bindings with improved alternatives. For example, I've replaced =^s= with =swiper-isearch=. So the binding still does the same thing, just better.

3. Global Leader - I borrow the concept of a "leader key" from vim and put every custom function I can there. This prevents conflicts with existing bindings and, since I'm using which-key, helps me remember the possibilities.

4. Mode Leader - All mode-spesific bindings (for example org-time-stamp), which don't make any sense elsewhere should go behind a uniform mode-leader key.

5. Keybindings which I use all the time, get taken out from behind leaders for faster access. For example, the org-agenda command.

** Enhance Emacs

#+begin_src emacs-lisp
(bind-key "C-s" 'swiper-isearch)
(bind-key "C-r" 'swiper-isearch-backward)
(bind-key "M-y" 'counsel-yank-pop)
(bind-key "M-<up>" 'move-line-up)
(bind-key "M-<down>" 'move-line-down)
(bind-key "M-o" 'other-window)
(bind-key "M-z" 'zap-up-to-char) ;the default is 'zap-to-char
(bind-key* "C-/" 'flyspell-correct-previous)
(bind-key "s-M-z" 'undo-tree-visualize)
(bind-key "M-s-s" 'save-some-buffers) ;save others
(bind-key "M-s-o" 'counsel-buffer-or-recentf)
(bind-key "M-s-f" 'swiper-all)
(bind-key "S-s-f" 'counsel-ag)
#+end_src

This cycles the spacing around point between a single space, no spaces, or the original spacing:

#+begin_src emacs-lisp
(bind-key "M-SPC" 'cycle-spacing)
#+end_src

** Primary Bindings

#+begin_src emacs-lisp
(bind-key "s-p" 'counsel-M-x)
(bind-key "s-b" 'ivy-switch-buffer)
(bind-key "M-s-b" 'ibuffer)
(bind-key "s-m" 'magit-status)
;; vim has the wonderful . command, and emacs has repeat
;; s-y is my keybinding because excel has (a version of) repeat bound to that
(bind-key "s-y" 'repeat)
(bind-key "s-j" 'hydra-modal/body)
(bind-key "s-;" 'hydra-flyspell/body)
(bind-key "s-|" 'hydra-manipulate/body)
(bind-key "s-t" 'hydra-transpose/body)
(bind-key "C-S-<mouse-1>" 'mc/add-cursor-on-click)

(bind-key "s-1" 'org-agenda)
(bind-key "s-2" 'hydra-secondary-selection/body)
#+end_src

** Global Leader Bindings

I use =⌘-'= as the my leader.

#+begin_src emacs-lisp
(bind-keys :prefix-map oht/global-leader
	   :prefix "s-'"
	   ("b" . counsel-descbinds)
	   ("c" . org-capture)
	   ("d" . sdcv-search)
	   ("f" . oht/counsel-find-org)
	   ("h" . hl-line-mode)
	   ("l" . oht/toggle-line-numbers)
	   ("o" . counsel-outline)
	   ("s-o" . counsel-org-goto-all)
	   ("w" . oht/toggle-whitespace)
	   ("m" . mc/edit-lines))
#+end_src

** Windows Leader

#+begin_src emacs-lisp
(bind-keys :prefix-map oht/windows-leader
	   :prefix "s-="
	   ("s" . oht/split-below)
	   ("v" . oht/split-beside)
	   ("h" . hydra-windows/body)
	   ("k" . delete-window)
	   ("o" . delete-other-windows)
	   ("b" . balance-windows))
#+end_src

** Mode Specific Bindings

I use =⌘-\= as the leader for mode-spesific bindings.

#+begin_src emacs-lisp
(with-eval-after-load 'org
  (define-key org-mode-map (kbd "s-\\ v") 'oht/fix-variable-org-indent)
  (define-key org-mode-map (kbd "s-\\ .") 'org-time-stamp)
  (define-key org-mode-map (kbd "s-\\ t") 'org-todo)
  (define-key org-mode-map (kbd "s-\\ s-t") 'counsel-org-tag)
  (define-key org-mode-map (kbd "s-\\ n") 'org-narrow-to-subtree)
  (define-key org-mode-map (kbd "s-\\ w") 'widen)
  (define-key org-mode-map (kbd "s-\\ s") 'org-search-view)
  (define-key org-mode-map (kbd "s-\\ <") 'org-insert-structure-template)
  (define-key org-mode-map (kbd "s-\\ l") 'org-store-link)
  (define-key org-mode-map (kbd "s-\\ i") 'org-insert-last-stored-link)
  (define-key org-mode-map (kbd "s-\\ m") 'org-toggle-link-display)
  (define-key org-mode-map (kbd "s-\\ I") 'org-clock-in)
  (define-key org-mode-map (kbd "s-\\ O") 'org-clock-out)
  (bind-key "s-\\ h" 'hydra-org/body)
  )

;; buffer menu bindings
(define-key Buffer-menu-mode-map "." 'hydra-buffer-menu/body)
#+end_src

# end of emacs-init.org
