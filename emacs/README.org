#+TITLE: Emacs Settings & Configuration
#+AUTHOR: Oliver Taylor

* Hello!

/Welcome to my emacs config!/ I'm sorry but I'm not writing this for you, I'm
writing this for me---well, /future/-me. I don't want to forget how this
configuration file works, or why I did things this way. This documentation is
designed to help me understand what the hell /past/-me was thinking.

There was a time not long ago when I maintained my configuration in a single,
monolithic, org document (that used =org-babel= to "tangle" it) but I've
switched to a more traditional approach of pure elisp. When I realized about
25% of my config was pure documentation, 50% had virtually no documentation,
and the remaining 25% only needed very little documentation, I decided to
switch to having a =README.org= file, and elisp files broken up by intended
function.

But 3 things in particular pushed me into doing it this way:

1. My emacs startup time was less snappy than I would have liked. Moving from
   a large org document to an elisp one made the startup time go from ~3.5
   seconds to ~1.5 seconds, which is nice (and I got it down below a second by
   switching from package.el to straight.el.
2. I realized that I was mostly using the org aspects of the config to navigate
   the document, which can also be done with =outline-minor-mode= and some careful
   keybindings.
3. I was running low on things to tinker with. ü§∑‚Äç‚ôÇÔ∏è

** My Emacs Philosophy

1. Emacs is not a text-editor in a traditional sense, it is a platform on which
   /you/ can program an editor that you'll love (and boy will you /have/ to). For
   people whose hobbies include tweaking dotfiles this is great! But it's not so
   great for people who just want to edit text.

2. If you want to dive in, I think the correct starting place is to accept that
   you will never remember Emacs keybindings, and that even if you do it will
   injure your pinky---so don't even bother trying. That's not a down-side, it
   means you don't have to learn anything new (!), just learn to make Emacs work
   the way you expect it to. That sounds like it might be difficult, but once
   you get the hang of customizing Emacs it becomes easy.

3. There's a few things you should know to use in order to learn about Emacs's
   capabilities. Poke around =C-h ?= for Help. Use =M-x= to explore. Use =which-key=
   to give you hints for difficult to remember shortcuts. Read the info pages,
   use =describe-key=, =describe-variable=, and =describe-function= a lot.

4. Use =hydra= to set up what are basically "mini-modes". I don't know how I'd
   function without the one I have setup for window management. And the Modal
   Editing hydra below is very useful indeed. As the saying goes "the best
   editor is not vim or emacs, but both".

** Keybindings Philosophy

1. Standard mac shortcuts should be supported wherever possible. And since mac
   inherits a lot of emacs keybindings anyway (and I use them outside emacs) I
   can leverage a lot of muscle memory. Additionally, I've largely internalized
   the =readline= keybindings (since I worked in =vim= for a long time) and so =^w=,
   =^u=, and =^h= are second-nature, so I'll want to use those as well.

2. Enhance Emacs built-in bindings with improved alternatives. For example, I've
   replaced =^s= and =^r= with =ctrlf=. So the binding still does the same thing, just
   better.

3. Global Leader - I borrow the concept of a "leader key" from vim and use it as
   a dumping ground for my most important commands, which don't have mac or
   Emacs equivalents.

4. Mode Leader - All mode-spesific bindings (for example =org-time-stamp=),
   which don't make any sense in any other mode go behind a uniform
   mode-leader key. I've picked =s-\=. That way, no matter what mode I'm in,
   I can hit the same key and see all the relevant functions.

5. Keybindings which I use all the time, get taken out from behind leaders for
   faster access. For example, the org-agenda command.

** Inspiration and References

Anyone learning vim, emacs, zsh, bash, or something similar, spends a lot of
time looking at other people's configuration files (much like this one). I've
learned from some wonderful (and well documented) examples. Here is a list of
the ones I've learned the most from:

- [[https://github.com/raxod502][Radon Rosborough's packages/config]]
- [[https://protesilaos.com/dotemacs/][Protesilaos Stavrou Dotemacs]]
- [[https://blog.aaronbieber.com][Aaron Bieber, Blog & Dotfiles]]
- [[https://github.com/hrs/dotfiles/blob/main/emacs/dot-emacs.d/configuration.org][Harry R. Schwartz dotfiles]]
- [[https://yiufung.net/post/org-mode-hidden-gems-pt1/][Org-Mode Hidden Gems]]
- [[https://github.com/angrybacon/dotemacs/blob/master/dotemacs.org][Angry Bacon dotemacs]]
- [[https://gitlab.com/Kaligule/emacs-config/-/blob/master/config.org][Kaligule config.org]]
- [[https://github.com/andschwa/.emacs.d][Andrew Schwartzmeyer‚Äôs Emacs configurations]]
- [[https://github.com/munen/emacs.d/][Alain M. Lafon's emacs.d]]

For more sources see [[https://pinboard.in/u:Oliver/t:emacs][my pinboard bookmarks]].

** Mitsuharu Yamamoto Fork

My preferred version of Emacs, and the one this configuration targets, is
[[https://bitbucket.org/mituharu/emacs-mac/raw/892fa7b2501a403b4f0aea8152df9d60d63f391a/README-mac][Mitsuharu Yamamoto's Emacs fork]] because it provides [[https://bitbucket.org/mituharu/emacs-mac/src/f3402395995bf70e50d6e65f841e44d5f9b4603c/README-mac?at=master&fileviewer=file-view-default][a lot of nice stuff]] for
people who want their Emacs to be a better macOS citizen.

* Key Binding Notes

<Control>-modified key bindings are case-insensitive. So =C-A= is identical to
=C-a=. You can bind shifted <Control> keystrokes with =C-S-a=. All other
modifiers are case-sensitive.

To decide what to do, Emacs looks at keymaps in this order: (1) Minor Mode,
(2) Major Mode, (3) Global.

How to define a key in the global keymap:

#+begin_src emacs-lisp
(global-set-key (kbd "C-z") 'shell)

(bind-key "C-z" 'shell)
(bind-keys ("C-z" . shell)
		   ("C-x" . ignore))
#+end_src

A given mode's keymaps are not constructed until the mode has been loaded. You
you must delay defining a new major/minor mode key until the mode has been
loaded. Do this with a mode hook like so:

	#+begin_src emacs-lisp
(add-hook 'texinfo-mode-hook
		  (lambda ()
		  (define-key textifo-mode-map (kbd "C-p") 'backward-paragraph)))

(bind-key "C-p" 'backward-paragraph textinfo-mode-map)
(bind-keys :map textinfo-mode-map
		   ("C-p" . backward-paragraph)
		   ("C-n" . forward-paragraph))
	#+end_src

To disable a global binding:

#+begin_src emacs-lisp
(global-unset-key (kbd "C-z"))
#+end_src

To disable a local binding:

	#+begin_src emacs-lisp
(add-hook 'org-mode-hook
	  (lambda ()
		(local-unset-key (kbd "C-c C-b"))))
	#+end_src

It's not key binding, but you can remap one command to another with:

#+begin_src emacs-lisp
(global-set-key [remap beginning-of-line] #'my/smart-beginning-of-line)
#+end_src

* Setting Variables

There are two kinds of variables, global ones, and buffer local ones.

=setq= simply sets the value of a variable, so if the variable global it sets
its value globally, and if the variable is buffer local it sets the value
locally (and new buffers will inherit the default value).

=setq-local= takes a global variable and makes a buffer local "copy" that
doesn't effect the global value.

=setq-default= takes a local variable and sets a new default value for all new
buffers, but doesn't change it in existing buffers.

* Packages

I came from Vim, where your init file is the only way to configure vim and if
it isn't in your init file then it doesn't exist. That approach makes a lot of
sense to me, and I used the delightful [[https://github.com/junegunn/vim-plug][vim-plug]], which assumes 2 key things:

1. Your init file is the canonical description of how you want the app to be
   configured, and only packages listed therein should be used.
2. External packages can be loaded from anywhere (local, github, etc).

Initially, I tried to learn the Emacs way (using only =package.el=) but
eventually came to the conclusion that the 2 above assumptions follow how I
want to work, and that the package [[https://github.com/raxod502/straight.el][straight.el]] makes Emacs work exactly this way.

** Straight

To use it, place the below in your init file. It simply installs the package
if you don't have it, and ensures (at startup) that =straight.el= is installed
and loaded.

#+begin_src emacs-lisp
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src

Straight works by finding the package on [[https://melpa.org][MELPA]] and cloning the linked git
repository to =~/.emacs.d/straight=. You can also load packages from any other
source with simple tweaks to the =straight-use-package= code. Installing and
loading a package is as simple as:

#+begin_src emacs-lisp
(straight-use-package 'el-patch)
#+end_src

** Use-Package

It took me a long time to actually understand what =use-package= is. The
website says:

#+begin_quote
The use-package macro allows you to isolate package configuration in your .emacs
file in a way that is both performance-oriented and, well, tidy.
#+end_quote

To me, this is a rather opaque description. I mean, you can isolate package
configuration by simply grouping all your settings for each package together
in a section. It also says it is *not* a package manager, but that it can
interface with them. Right. So, what does =use-package= do again?

Here's what I do:

- Use =straight.el= to install/update packages.
- Use =use-package= to /precisely control the loading of packages/ and /configure
  them/.

If you simply put =(require magit)= in your config then when Emacs reads that
function it will "load" the =magit= package. At first glance this makes sense. If
you want to use =magit= then you need it loaded. The problem is that Emacs does
this on startup, regardless of if you need =magit= on startup. As the number of
packages you install grows so too will Emacs startup time, and Emacs will be
"running heavy" with all those packages loaded and ready to go, regardless of
your need for them.

Contrast with this:

#+begin_src emacs-lisp
(use-package magit
  :commands magit-status)
#+end_src

This short config snippet tells Emacs to load magit only when you trigger the
=magit-status= function.

Finally, a setting I like to have enabled is =use-package-always-defer=. This
means no package will be loaded unless you explicitly tell Emacs to load it.
Rather than the simple installation of a package controlling what's loaded
(and always at startup) I want to /precisely control the loading of packages/.

** A Winning Combo

You can configure =straight.el= to determine what to install based your
use-package delcatrations with the code:

#+begin_src emacs-lisp
(setq straight-use-package-by-default t)
#+end_src

That way, you can install, load, and configure packages in one step with
something like:

#+begin_src emacs-lisp
(use-package expand-region
  :bind
  ("s-e" . er/expand-region)
  ("s-E" . er/contract-region)
  )
#+end_src

* Minimum

I've codified the above into a simple init file called =minimum.el= which provides the following features:

1. Installs =straight= and =use-package=, and integrates them as described above.
2. Sets use-package to defer loading of all packages.
3. Installs the packages:
     1. =which-key=, =bind-key=, =whole-line-or-region=
     2. =selectrum=, =selectrum-precient=, =marginalia=
4. Creates a basic set of Mac-like keybindings.
5. Provides some convenience bindings for my most used Emacs features.

For details read the comments in the file.
